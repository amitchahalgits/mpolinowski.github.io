"use strict";(self.webpackChunkmikes_dev_notebook=self.webpackChunkmikes_dev_notebook||[]).push([[22058],{186137:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>c,frontMatter:()=>a,metadata:()=>l,toc:()=>h});var i=t(785893),s=t(603905);const a={sidebar_position:1e4,slug:"2018-01-02",title:"Machine Learning with SciKit Learn",authors:"mpolinowski",tags:["Machine Learning","Python","SciKit"]},r="Prerequisite",l={id:"IoT-and-Machine-Learning/ML/2018-01-02--machine-learning-with-python/index",title:"Machine Learning with SciKit Learn",description:"Shenzhen, China",source:"@site/docs/IoT-and-Machine-Learning/ML/2018-01-02--machine-learning-with-python/index.mdx",sourceDirName:"IoT-and-Machine-Learning/ML/2018-01-02--machine-learning-with-python",slug:"/IoT-and-Machine-Learning/ML/2018-01-02--machine-learning-with-python/2018-01-02",permalink:"/docs/IoT-and-Machine-Learning/ML/2018-01-02--machine-learning-with-python/2018-01-02",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/IoT-and-Machine-Learning/ML/2018-01-02--machine-learning-with-python/index.mdx",tags:[{label:"Machine Learning",permalink:"/docs/tags/machine-learning"},{label:"Python",permalink:"/docs/tags/python"},{label:"SciKit",permalink:"/docs/tags/sci-kit"}],version:"current",sidebarPosition:1e4,frontMatter:{sidebar_position:1e4,slug:"2018-01-02",title:"Machine Learning with SciKit Learn",authors:"mpolinowski",tags:["Machine Learning","Python","SciKit"]},sidebar:"tutorialSidebar",previous:{title:"Introduction to TensorFlow 2 Beta",permalink:"/docs/IoT-and-Machine-Learning/ML/2019-03-31--introduction-to-tensorflow-2-beta/2019-03-31"},next:{title:"AIOps",permalink:"/docs/category/aiops"}},o={},h=[{value:"Data Representation",id:"data-representation",level:2},{value:"Data Preprocessing",id:"data-preprocessing",level:2},{value:"SciKit-Learn API",id:"scikit-learn-api",level:2},{value:"Estimation",id:"estimation",level:2},{value:"Predictor",id:"predictor",level:2},{value:"Transformer",id:"transformer",level:2},{value:"Clustering Tasks",id:"clustering-tasks",level:2},{value:"Clustering",id:"clustering",level:2},{value:"Visualization",id:"visualization",level:2},{value:"k-Means Algorithm",id:"k-means-algorithm",level:2},{value:"Initialization Methods",id:"initialization-methods",level:3},{value:"Mean-Shift Algorithm",id:"mean-shift-algorithm",level:2},{value:"DBSCAN Algorithm",id:"dbscan-algorithm",level:2},{value:"Evaluating Performance",id:"evaluating-performance",level:2},{value:"Classification Tasks",id:"classification-tasks",level:2},{value:"Regression Tasks",id:"regression-tasks",level:2},{value:"Data Split",id:"data-split",level:2},{value:"Cross Validation",id:"cross-validation",level:2},{value:"Metric Evaluation",id:"metric-evaluation",level:2},{value:"Table of Confusion",id:"table-of-confusion",level:2},{value:"Evaluation of Tasks with binary output labels",id:"evaluation-of-tasks-with-binary-output-labels",level:3},{value:"Evaluation of Regression Tasks",id:"evaluation-of-regression-tasks",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.ah)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Shenzhen, China",src:t(284990).Z+"",width:"1500",height:"480"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#prerequisite",children:"Prerequisite"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#scikit-introduction",children:"SciKit Introduction"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#data-representation",children:"Data Representation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#data-preprocessing",children:"Data Preprocessing"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#scikit-learn-api",children:"SciKit-Learn API"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#estimation",children:"Estimation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#predictor",children:"Predictor"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#transformer",children:"Transformer"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#unsupervised-learning-introduction",children:"Unsupervised Learning Introduction"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#clustering-tasks",children:"Clustering Tasks"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#unsupervised-learning-irl",children:"Unsupervised Learning IRL"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#clustering",children:"Clustering"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#visualization",children:"Visualization"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#k-means-algorithm",children:"k-Means Algorithm"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#initialization-methods",children:"Initialization Methods"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#mean-shift-algorithm",children:"Mean-Shift Algorithm"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#dbscan-algorithm",children:"DBSCAN Algorithm"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#evaluating-performance",children:"Evaluating Performance"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#supervised-learning-introduction",children:"Supervised Learning Introduction"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#classification-tasks",children:"Classification Tasks"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#regression-tasks",children:"Regression Tasks"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#supervised-learning-irl",children:"Supervised Learning IRL"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#data-split",children:"Data Split"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#cross-validation",children:"Cross Validation"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#metric-evaluation",children:"Metric Evaluation"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#table-of-confusion",children:"Table of Confusion"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#evaluation-of-tasks-with-binary-output-labels",children:"Evaluation of Tasks with binary output labels"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#evaluation-of-regression-tasks",children:"Evaluation of Regression Tasks"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"An Introduction in building machine learning applications with the SciKit Python library. Learn data preprocessing and implement supervised and unsupervised algorithms as well as performing error analysis to evaluate their performance."}),"\n",(0,i.jsx)(n.h1,{id:"prerequisite",children:"Prerequisite"}),"\n",(0,i.jsxs)(n.p,{children:["First we need to install the ",(0,i.jsx)(n.a,{href:"https://www.anaconda.com/download/",children:"Anaconda Environment"})," for Windows, macOS or LINUX. This package combines everything we need to get started with Python. From libraries like ",(0,i.jsx)(n.a,{href:"https://scikit-learn.org/stable/",children:"SciKit-Learn"}),", Pandas and Matplotlib to Jupyter Notebook, that will help us to execute our Python scripts."]}),"\n",(0,i.jsxs)(n.p,{children:["We will begin working with the ",(0,i.jsx)(n.a,{href:"https://anaconda.org/anaconda/seaborn",children:"Seaborn Package"})," dataset that is included in the Anaconda package to become familiar with Python based data analysis."]}),"\n",(0,i.jsxs)(n.p,{children:["In the later steps, we are going to use publicly available data from the ",(0,i.jsx)(n.a,{href:"https://archive.ics.uci.edu",children:"UCI Archive"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"http://archive.ics.uci.edu/ml/datasets/Wholesale+customers",children:"Wholesale Customer Dataset"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://archive.ics.uci.edu/ml/datasets/Fertility",children:"Adult Fertility Study"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://archive.ics.uci.edu/ml/machine-learning-databases/00244/",children:"https://archive.ics.uci.edu/ml/machine-learning-databases/00244/"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://archive.ics.uci.edu/ml/machine-learning-databases/adult/",children:"https://archive.ics.uci.edu/ml/machine-learning-databases/adult/"})}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.a,{href:"https://archive.ics.uci.edu/ml/datasets/Bank+Marketing",children:"Bank+Marketing Study"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://archive.ics.uci.edu/ml/machine-learning-databases/00222/",children:"https://archive.ics.uci.edu/ml/machine-learning-databases/00222/"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h1,{id:"scikit-introduction",children:"SciKit Introduction"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://scikit-learn.org/",children:"SciKit-Learn"})," is a OpenSource library for building models based on built-in machine learning and statistical algorithms. The library offers both supervised and unsupervised models, that we will use to analyze our data with."]}),"\n",(0,i.jsx)(n.p,{children:"The library is used to:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Interpret data and train models"}),"\n",(0,i.jsx)(n.li,{children:"Perform predictions from data sets"}),"\n",(0,i.jsx)(n.li,{children:"Cross validation and performance metric analysis"}),"\n",(0,i.jsx)(n.li,{children:"To create sample data sets and test algorithms"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"data-representation",children:"Data Representation"}),"\n",(0,i.jsx)(n.p,{children:"To feed data into SciKit it needs to be represented as a table or matrix. Most data used in machine learning is 2-dimensional - that means it can be represented by a classical Excel sheet with rows and columns:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Rows represent observations (instances)"}),"\n",(0,i.jsx)(n.li,{children:"Columns represent characteristics (features)"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Datasets often have many features that will be represented in the ",(0,i.jsx)(n.strong,{children:"Feature Matrix"}),". In most cases it will only be one or two features that will separated for the later analysis of the data set - this skimmed down dataset is called the ",(0,i.jsx)(n.strong,{children:"Target Matrix"}),":"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Feature Matrix"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Contains data from each instance for all features"}),"\n",(0,i.jsxs)(n.li,{children:["The dimensions of the matrix are ",(0,i.jsx)(n.code,{children:"[n_i, n_f]"})," denoting the number of instances and features."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Target Matrix"})}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Is usually 1-dimensional as it only contains 1 feature for all instances. If more than 1 feature is necessary to describe the model the dimension increases accordingly."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The Feature Matrix is usually stored in the variable ",(0,i.jsx)(n.strong,{children:"X"}),", while the variable ",(0,i.jsx)(n.strong,{children:"Y"})," is used to store the ",(0,i.jsx)(n.strong,{children:"Target Matrix"}),". Both matrices can be created by using a ",(0,i.jsx)(n.strong,{children:"NumPy Array"})," or a ",(0,i.jsx)(n.strong,{children:"Panda DataFrame"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["In the following example we are going to look at plant statistic from the ",(0,i.jsx)(n.a,{href:"https://anaconda.org/anaconda/seaborn",children:"Seaborn Package"})," included in the ",(0,i.jsx)(n.a,{href:"https://www.anaconda.com/download/",children:"Anaconda Environment"}),". Each row in the set will represent a species of the Setosa family and columns represent the plant characteristics of the sepal as well as petal length and width:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Python SciKit-Learn",src:t(246780).Z+"",width:"800",height:"622"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["We import the ",(0,i.jsx)(n.strong,{children:"Seaborn"})," package into the variable ",(0,i.jsx)(n.strong,{children:"sns"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["We can now extract the ",(0,i.jsx)(n.strong,{children:"Iris Dataset"})," from it and store the data inside the variable ",(0,i.jsx)(n.strong,{children:"iris"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["We then drop the ",(0,i.jsx)(n.strong,{children:"Species Feature"})," from the dataset and store it inside the variable ",(0,i.jsx)(n.strong,{children:"X"}),". Thus the ",(0,i.jsx)(n.strong,{children:"Feature Matrix"})," consists of all the features ",(0,i.jsx)(n.strong,{children:"BUT"})," the target for all instances. Making it a 2 dimensional dataset."]}),"\n",(0,i.jsx)(n.li,{children:"Now we can have a look at the top 10 rows of our data to get an idea what it looks like."}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.strong,{children:"Shape"})," command shows us that we have a ",(0,i.jsx)(n.strong,{children:"Feature Matrix"})," that consists of ",(0,i.jsx)(n.em,{children:"150 rows"})," (instances) and ",(0,i.jsx)(n.em,{children:"4 columns"})," (features)."]}),"\n",(0,i.jsxs)(n.li,{children:["We will now build the ",(0,i.jsx)(n.strong,{children:"Target Matrix"})," based on the ",(0,i.jsx)(n.strong,{children:"Species Feature"})," and store it in the variable ",(0,i.jsx)(n.strong,{children:"Y"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["And we see that the first 10 species all belong to the Setosa family. The ",(0,i.jsx)(n.strong,{children:"Target Matrix"})," is now reduced from the earlier 2 to 1 dimension - only consisting of the target feature for all instances."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"data-preprocessing",children:"Data Preprocessing"}),"\n",(0,i.jsxs)(n.p,{children:["IRL datasets are usually not analysis-friendly (",(0,i.jsx)(n.strong,{children:"messy data"}),"), as they are containing ",(0,i.jsx)(n.em,{children:"noisy data"}),", ",(0,i.jsx)(n.em,{children:"missing entries"})," and ",(0,i.jsx)(n.em,{children:"outliers"})," that need to be dealt with before feeding them to our algorithm."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Dealing with Missing Values"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Eliminate Data"}),"\n",(0,i.jsxs)(n.li,{children:["Or Replace it","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mean Imputation"})," - filling out missing fields using the mean or median value (",(0,i.jsx)(n.em,{children:"may introduce bias to our model"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Regression Imputation"})," - Use prediction to fill out the values (",(0,i.jsx)(n.em,{children:"may end up overfitting the model"}),")"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["String-based values should be replaced with a class (",(0,i.jsx)(n.em,{children:"like  'uncategorized'"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Dealing with Outliers"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Outliers represent values that are far from the mean (often set to ",(0,i.jsx)(n.strong,{children:"3-6 standard deviations"})," when the data set follows a Gaussian distribution). If the values follow a Gaussian distribution, ",(0,i.jsx)(n.em,{children:"global outliers"})," are located at the tails of the bell curve. While ",(0,i.jsx)(n.em,{children:"local outliers"})," are inside the distribution but far off the group of data points they are associated with. E.g. a vehicle that can drive 500 MPH is a global outlier in a car statistic. While a truck that only has 40 hp is a local outlier in the group labeled as trucks, but is still well inside the curve of the vehicle dataset."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Delete Outliers."}),"\n",(0,i.jsxs)(n.li,{children:["If all instances above a certain value of a feature behave the same way, you can ",(0,i.jsx)(n.strong,{children:"define a top"})," for that feature and apply it to outliers."]}),"\n",(0,i.jsxs)(n.li,{children:["Replace the value (",(0,i.jsx)(n.strong,{children:"Mean"})," or ",(0,i.jsx)(n.strong,{children:"Regression"}),")."]}),"\n",(0,i.jsx)(n.li,{children:"String values (e.g. misspelled features) can be eliminated or corrected (when possible)."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["In the following example we will again use the ",(0,i.jsx)(n.a,{href:"https://anaconda.org/anaconda/seaborn",children:"Seaborn Package"})," included in the ",(0,i.jsx)(n.a,{href:"https://www.anaconda.com/download/",children:"Anaconda Environment"})," and take a look at the age of the passengers of the ",(0,i.jsx)(n.strong,{children:"Titantic"}),":"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Python SciKit-Learn",src:t(576934).Z+"",width:"800",height:"1284"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["We import the ",(0,i.jsx)(n.strong,{children:"Seaborn"})," package and store the ",(0,i.jsx)(n.strong,{children:"Titanic Dataset"})," inside the variable ",(0,i.jsx)(n.em,{children:"titanic"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["We then load the ",(0,i.jsx)(n.strong,{children:"Age Feature"})," from the dataset and store it in the variable ",(0,i.jsx)(n.em,{children:"age"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["Displaying the first 10 rows shows us that we already have a missing entry (",(0,i.jsx)(n.strong,{children:"NaN"}),", ",(0,i.jsx)(n.em,{children:"not a number"}),"). The ",(0,i.jsx)(n.em,{children:"shape"})," command shows us that there are 891 rows in total."]}),"\n",(0,i.jsxs)(n.li,{children:["We can check how many of those 891 have a value of NaN with the ",(0,i.jsx)(n.em,{children:"isnull"})," function. Summing them up shows us that we have 177 passengers of the Titanic where we do not know there age."]}),"\n",(0,i.jsxs)(n.li,{children:["We can now use the ",(0,i.jsx)(n.strong,{children:"Mean Method"})," to replace all of those with the mean age. For this we call the mean method on the values in ",(0,i.jsx)(n.em,{children:"age"}),", round them up and store them inside the variable ",(0,i.jsx)(n.em,{children:"mean"}),". Printing out the value, we can see that the mean age was ",(0,i.jsx)(n.em,{children:"30"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["We can now use the ",(0,i.jsx)(n.strong,{children:"fillna Method"})," to fill out every value that is NaN with the mean value. Taking a look at the first 10 rows again shows that the missing value has now been filled with the mean value 30."]}),"\n",(0,i.jsxs)(n.li,{children:["To display our distribution - to be able to spot ",(0,i.jsx)(n.strong,{children:"Outliers"})," - we import ",(0,i.jsx)(n.em,{children:"PyPlot"})," from the ",(0,i.jsx)(n.em,{children:"MatPlotLib"})," library as ",(0,i.jsx)(n.em,{children:"plt"}),". We use the plt method to build a histogram of the values stored inside the ",(0,i.jsx)(n.em,{children:"age"})," variable and display the output with the show function."]}),"\n",(0,i.jsxs)(n.li,{children:["To spot outliers we will set the ",(0,i.jsx)(n.strong,{children:"Minimum Value"})," that we will accept for our model as the mean value for age MINUS ",(0,i.jsx)(n.em,{children:"3-times the standard deviation"})," of the age dataset. This turns out to be a negative value - given that this does not make any sense in our particular dataset, we can ignore outliers on minimum side of the distribution."]}),"\n",(0,i.jsxs)(n.li,{children:["To spot outliers we will set the ",(0,i.jsx)(n.strong,{children:"Maximum Value"})," that we will accept for our model as the mean value for age PLUS ",(0,i.jsx)(n.em,{children:"3-times the standard deviation"})," of the age dataset. Everyone who is listed as ~ 69 or above can be treated as an outlier."]}),"\n",(0,i.jsxs)(n.li,{children:["We can thus define our ",(0,i.jsx)(n.em,{children:"outlier"})," variable as every value inside ",(0,i.jsx)(n.em,{children:"age"})," that is greater than ",(0,i.jsx)(n.em,{children:"max_val"}),". Counting the outliers shows us that we have ",(0,i.jsx)(n.em,{children:"7"})," inside our dataset."]}),"\n",(0,i.jsxs)(n.li,{children:["We decide to remove all outliers from our dataset by only accepting values into our ",(0,i.jsx)(n.em,{children:"age"})," variable that are smaller or equal to ",(0,i.jsx)(n.em,{children:"max_val"}),". The shape command shows us that out of the initial 891 passengers we now eliminated 7 from our analysis - ",(0,i.jsx)(n.em,{children:"884"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"scikit-learn-api",children:"SciKit-Learn API"}),"\n",(0,i.jsx)(n.p,{children:"SciKit-Learn offers us a unified syntax to make machine learning more accessible. The SciKit-Learn API is divided into 3 interfaces:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Estimator Interface"}),": Used to create models and integrate your data."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Predictor Interface"}),": Used to make predictions based on the models created."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Transformer Interface"}),": Used to transform data files."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"estimation",children:"Estimation"}),"\n",(0,i.jsxs)(n.p,{children:["This is the interface that you use to initialize a model and apply a fit() method to your data. Your data is received as two variables - ",(0,i.jsx)(n.strong,{children:"X_train"})," is the feature matrix and ",(0,i.jsx)(n.strong,{children:"Y_train"})," the target matrix for your model. ",(0,i.jsx)(n.em,{children:"Unsupervised Models"})," only use the first of those two arguments. A ",(0,i.jsx)(n.em,{children:"Supervised Model"})," takes both."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from sklearn.naive_bayes import GaussianNB\r\nmodel = GaussianNB()\r\nmodel.fit(X_train, Y_train)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the example of a supervised model, we imported the model we want to use, store it in the variable ",(0,i.jsx)(n.code,{children:"model"})," and then apply it to our two arguments using the fit() method."]}),"\n",(0,i.jsx)(n.p,{children:"The Estimator can perform 3 more tasks for us:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Feature Extraction"}),": A transformation of the input data into numerical features."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Feature Selection"}),": Selecting a feature from your data that most contributes to the prediction output."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Dimensionality"}),": Converting your data into a lower dimension."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"predictor",children:"Predictor"}),"\n",(0,i.jsxs)(n.p,{children:["The Predictor interface performs prediction based on the model you trained. In supervised models it creates a new dataset called ",(0,i.jsx)(n.strong,{children:"X_test"})," and re-feeds it to your model. The implementation looks as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"Y_pred = model.predict(X_test)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This allows us to quantify the ",(0,i.jsx)(n.strong,{children:"Confidence"})," or ",(0,i.jsx)(n.strong,{children:"Performance"})," of a model by comparing how far ",(0,i.jsx)(n.em,{children:"X_test"})," differs from ",(0,i.jsx)(n.em,{children:"Y_test"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"transformer",children:"Transformer"}),"\n",(0,i.jsxs)(n.p,{children:["The Transform interface gives us a transform() method to preprocess our input data. Using the same transformation for the data that we use to train our model as well as the for the data we later use the model on to perform predictions ensures that both datasets are comparable in their distribution. An example is the ",(0,i.jsx)(n.strong,{children:"Normalization"})," of a dataset:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"from sklearn.preprocessing import StandardScaler\r\nscaler = StandardScaler()\r\nscaler.fit(X_train)\r\nX_train = scaler.transform(X_train)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here we imported the transformer and store it inside the variable ",(0,i.jsx)(n.code,{children:"scaler"}),". Our dataset is then fit to the imported method and the transformation performed."]}),"\n",(0,i.jsx)(n.h1,{id:"unsupervised-learning-introduction",children:"Unsupervised Learning Introduction"}),"\n",(0,i.jsx)(n.p,{children:"In unsupervised learning the model is modelled to the data, without any relationship to an output label. It can be used to show up clusters of similarities inside unlabeled data."}),"\n",(0,i.jsx)(n.h2,{id:"clustering-tasks",children:"Clustering Tasks"}),"\n",(0,i.jsx)(n.p,{children:"Finding clusters in unlabeled data involves grouping instances that are similar to each other, while differing visibly from instances in other groups. The most popular Clustering Algorithms are:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"k-means"}),": Separating instances in ",(0,i.jsx)(n.em,{children:"n"})," clusters of equal variance by minimizing the sum of the squared distances between 2 points - ",(0,i.jsx)(n.em,{children:"Centroid-based Model"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mean-shift clustering"}),": Using centroids to create a cluster, where every instances is a candidate to become a centroid (mean of the points in that cluster) - ",(0,i.jsx)(n.em,{children:"Centroid-based Model"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"DBSCAN"}),": ",(0,i.jsx)(n.em,{children:"Density-based spatial clustering of applications with noise"})," separates areas with high densities of points as clusters from areas with a low density - ",(0,i.jsx)(n.em,{children:"Density-based Model"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Gaussian"}),": The belonging to a cluster is shown as a deviation from a distribution as used in an expectation maximization model - ",(0,i.jsx)(n.em,{children:"Distribution-based Models"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hierarchial"}),": Similarity as proximity inside the data space - ",(0,i.jsx)(n.em,{children:"Connectivity-based Model"})]}),"\n"]}),"\n",(0,i.jsx)(n.h1,{id:"unsupervised-learning-irl",children:"Unsupervised Learning IRL"}),"\n",(0,i.jsx)(n.p,{children:"We want to use unsupervised models  to analyze data sets from real-world applications. The Objectives are:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Understanding different clustering techniques"}),"\n",(0,i.jsx)(n.li,{children:"Using Panda Dataframes"}),"\n",(0,i.jsx)(n.li,{children:"Data visualizations with MatPlotLib"}),"\n",(0,i.jsx)(n.li,{children:"Working with algorithms like k-means, mean-shift and DBSCAN"}),"\n",(0,i.jsx)(n.li,{children:"Using performance metrics to decide which one to use"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"clustering",children:"Clustering"}),"\n",(0,i.jsxs)(n.p,{children:["Clustering is a type of unsupervised machine-learning technique to find pattern in unlabeled input data and divide data points into ",(0,i.jsx)(n.em,{children:"n"})," clusters based on similarity (and difference to data points in other cluster). The assignment to a cluster can either be ",(0,i.jsx)(n.strong,{children:"hard"})," (absolute designation) or ",(0,i.jsx)(n.strong,{children:"soft"})," (probability of belonging to a cluster). Real-world applications are:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Search Engine Results"}),"\n",(0,i.jsx)(n.li,{children:"Recommendation Programs"}),"\n",(0,i.jsx)(n.li,{children:"Image Recognition"}),"\n",(0,i.jsx)(n.li,{children:"Market Segmentation for targeted Marketing"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["We are going to use the ",(0,i.jsx)(n.a,{href:"#prerequisite",children:"Wholesale Customer Dataset"})," from the UC Irvine Machine Learning Repository to explore those techniques."]}),"\n",(0,i.jsx)(n.h2,{id:"visualization",children:"Visualization"}),"\n",(0,i.jsxs)(n.p,{children:["Visual representations of datasets help us to understand relationships in datasets, results and performance of a model. To work with Visualizations we can load our data into a ",(0,i.jsx)(n.strong,{children:"Dataframe"})," using ",(0,i.jsx)(n.strong,{children:"Pandas"}),". Panda dataframes manage stored data in a 2-dimensional, size-mutable matrix with labelled axes and are often stored in ",(0,i.jsx)(n.em,{children:"*.csv"})," files - like the example of the ",(0,i.jsx)(n.a,{href:"#prerequisite",children:"Wholesale Customer Dataset"}),". Data presented this way can be easily loaded into a frame using the Panda function ",(0,i.jsx)(n.strong,{children:"read.csv()"})," (there are alternatives for data based in Excel sheets or SQL databases - ",(0,i.jsx)(n.em,{children:"read.xlx()"})," and ",(0,i.jsx)(n.em,{children:"read.sql()"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import pandas as pd\r\n\r\nfile_path = './wholesale-customers-data.csv'\r\ndata = pd.read_csv(file_path)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To create a visual representation of such a dataframe we can use the Python library ",(0,i.jsx)(n.strong,{children:"Matplotlib"})," and create:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Histograms (",(0,i.jsx)(n.em,{children:"plt.hist()"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["Scatter Plots (",(0,i.jsx)(n.em,{children:"plt.scatter()"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["Bar Charts (",(0,i.jsx)(n.em,{children:"plt.bar()"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["Pie Charts (",(0,i.jsx)(n.em,{children:"plt.pie()"}),")"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Python SciKit-Learn",src:t(780906).Z+"",width:"800",height:"694"})}),"\n",(0,i.jsxs)(n.p,{children:["In this example we used the ",(0,i.jsx)(n.strong,{children:"Numpy"})," random number generator and ",(0,i.jsx)(n.em,{children:"make_circles()"})," method to generate a dataset and created a scatter plot and a histogram from it using Matplotlib."]}),"\n",(0,i.jsx)(n.h2,{id:"k-means-algorithm",children:"k-Means Algorithm"}),"\n",(0,i.jsxs)(n.p,{children:["The k-means algorithm is used on unlabelled data to divide it into ",(0,i.jsx)(n.em,{children:"K"})," number of clustered subgroups based on similarity. The ",(0,i.jsx)(n.strong,{children:"Centroid"})," of each cluster represents a collection of features that can be used to define the members of the cluster."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Initialization"}),": Based on the number of clusters set by you, centroids are generated by initial estimates or at random."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Assignment"}),": All data points are assigned to the nearest cluster."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Update"}),": Centroids are recalculated by computing the mean of all data points inside the cluster."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The algorithm runs until:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"It reaches the number of preset iterations."}),"\n",(0,i.jsx)(n.li,{children:"Data points no longer change from one cluster to another."}),"\n",(0,i.jsx)(n.li,{children:"The Euclidean distance between all data points and their assigned centroid is minimized."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"initialization-methods",children:"Initialization Methods"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"k-means++"})," (default) method chooses the initial centroids randomly with a maximized distance from other centroids."]}),"\n",(0,i.jsx)(n.p,{children:"The number of centroids has to be chosen by you to minimize the average cluster distance in relation to it's centroids. At a small number of centroids, the distance between forming clusters is high. The distance reduces the more initial centroids are added to the calculation - until a point where it stagnates. Adding more centroids after that point will falsify the results by over-representation of features by data points inside the cluster."}),"\n",(0,i.jsx)(n.p,{children:"By plotting the distances between clusters against the number of clusters, the ideal number of centroids is given by the breaking point, where the rate decreases suddenly. In the example below we can see that the distances between points inside a cluster is very high, when we start with 1 centroid. It is very low with 15 centroids. k can be set to 5 as it is the point where the similarity between data points inside the cluster no longer increase significantly when we keep sub-dividing clusters:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Python SciKit-Learn",src:t(649148).Z+"",width:"800",height:"647"})}),"\n",(0,i.jsxs)(n.p,{children:["Here we imported the ",(0,i.jsx)(n.em,{children:"sklearn.cluster"})," packages as KMeans and initialize ",(0,i.jsx)(n.em,{children:"ideal_k"}),", which is then filled with a for-loop calculating the inertia (the average distance between data points within a cluster) as a function of the number of clusters inside our dataset. With every loop the number of clusters ",(0,i.jsx)(n.em,{children:"i"})," is increased by 1 until we reach 15."]}),"\n",(0,i.jsxs)(n.p,{children:["We can then convert the array to a Numpy array and plot the data. We can see a sharp decrease in rate around 4-6, telling us that ",(0,i.jsx)(n.em,{children:"k=5"})," would be a good place to initialize our analysis with."]}),"\n",(0,i.jsxs)(n.p,{children:["We can now initialize our analysis by setting the number of centroids to 5, fit the dataset with k-means and predict what cluster a data point belongs to. To visualize the result we want to set the colour for each data point inside a cluster to ",(0,i.jsx)(n.code,{children:"c=pred_kmeans"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The results below show the plot for a number of 5, 4 and 6 clusters inside the dataset:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Python SciKit-Learn",src:t(472538).Z+"",width:"800",height:"1096"})}),"\n",(0,i.jsx)(n.h2,{id:"mean-shift-algorithm",children:"Mean-Shift Algorithm"}),"\n",(0,i.jsxs)(n.p,{children:["While the ",(0,i.jsx)(n.strong,{children:"k-mean"})," algorithm assigns a data point to a cluster as a function of the distance to a centroid, the ",(0,i.jsx)(n.strong,{children:"mean-shift"})," algorithm evaluates the density of data points in the data space to define clusters."]}),"\n",(0,i.jsxs)(n.p,{children:["The mean-shift algorithm represents the data points as a ",(0,i.jsx)(n.strong,{children:"density distribution"})," (KDE - ",(0,i.jsx)(n.em,{children:"Kernel Density Estimation"}),")."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Python SciKit-Learn",src:t(868836).Z+"",width:"801",height:"1149"})}),"\n",(0,i.jsx)(n.p,{children:"As we can see we are getting the same result here as with the k-means algorithm - we just did not have to define the number of centroids."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Note"})," that you can influence the amount of clusters found by assigning different ",(0,i.jsx)(n.strong,{children:"bandwidths"})," - the example above varies the bandwidth between 0.4-0.6 as the data set was normalized between 0-1 (when you are working with data with values between 0-2000, you should adjust the bandwidth to ~ 100-500 to get sensible results). The bandwidth represents the size of a window that is drawn around each data point. With every iteration the mean-shift algorithm calculates the mean of each window, based on the data points it contains, and shifts each window towards the mean. This process is repeated until every point is shifted to the nearest peak in the density distribution. The number of shifts a data point has to undergo depends on the distance to the peak and the window size (bandwidth) that is used. Every data point in a peak of the distribution belongs to that cluster."]}),"\n",(0,i.jsx)(n.h2,{id:"dbscan-algorithm",children:"DBSCAN Algorithm"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.em,{children:"density-based spatial clustering of applications with noise"})," (",(0,i.jsx)(n.strong,{children:"DBSCAN"}),") algorithm groups points that are close to each other and marks points that have no close neighbors as ",(0,i.jsx)(n.strong,{children:"outliers"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"The algorithm requires two main parameters:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Epsilon"})," (",(0,i.jsx)(n.em,{children:"eps"}),"): as the maximum distances within which the algorithm searches for neighbors. Epsilon, just like the bandwidth in case of the mean-shift algorithm, has to be adapted to the value of your data point."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Minimum Number of Observations"})," (",(0,i.jsx)(n.em,{children:"min_sample"}),"): as the number of data points required to form a high density area. Note that SciKit learn this value is set to 5 by default and it is optional for you to change this value if necessary."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Given these requirements each data point can be classified as:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Core Point"}),": when it has at least the minimum number of data points within it's eps radius."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Border Point"}),": when it is within the eps radius of a core point but does not have the required minimum number of data points within it's own radius."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Noise Point"}),": when none of the above is true."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Python SciKit-Learn",src:t(606053).Z+"",width:"800",height:"1093"})}),"\n",(0,i.jsx)(n.h2,{id:"evaluating-performance",children:"Evaluating Performance"}),"\n",(0,i.jsx)(n.p,{children:"Once we applied an algorithm to form clusters inside our data set we now have to have a way to evaluate the performance of those clusters - was the algorithm and parameters we choose the best option for the given task?"}),"\n",(0,i.jsxs)(n.p,{children:["In case of a ",(0,i.jsx)(n.strong,{children:"Supervised Algorithm"})," this can be done by comparing the predictions we get with the true value we know. In case of an ",(0,i.jsx)(n.strong,{children:"Unsupervised Model"})," this is not possible. For clustering algorithm we have the option to measure the similarity of data points within a cluster to estimate the performance of the chosen algorithm."]}),"\n",(0,i.jsx)(n.p,{children:"SciKit Learn offers two method to evaluate the performance of unsupervised clustering algorithms by measuring how well-defined the clusters edges are (instead of measuring the dispersion within the cluster). We have to keep in mind that those methods don't take the size of each cluster into account."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Silhouette Coefficient Score"}),": Calculates the mean distance between each point inside their cluster (a) and the mean distance to it's nearest other clusters (b). The coefficient is calculated by ",(0,i.jsx)(n.code,{children:"s = (b-a)/max(a,b)"})," and results in a score between -1 and 1 - the lower the value, the worse the performance of the cluster. A special case is a value of 0 where clusters start to overlap. This scoring system ",(0,i.jsx)(n.strong,{children:"does not work"})," with density based algorithms like DBSCAN."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Calinski-Harabasz Index"}),": Calculates the variance of each cluster by the mean square error of each point to the centroid of that cluster. This is then compared to the overall inter-cluster variance. A higher value describes a better definition/separation of each cluster. This scoring system ",(0,i.jsx)(n.strong,{children:"does not work"})," with density based algorithms like DBSCAN."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"SciKit Learn does not offer a scoring system that works reliable for density-based algorithms."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Python SciKit-Learn",src:t(977562).Z+"",width:"800",height:"385"})}),"\n",(0,i.jsxs)(n.p,{children:["As we see above, we are getting comparable scores for the k-mean and mean-shift algorithm with the ",(0,i.jsx)(n.strong,{children:"silhouette_score"})," - k-mean (",(0,i.jsx)(n.em,{children:"0.360"}),") is works slightly better than mean-shift (",(0,i.jsx)(n.em,{children:"0.344"}),"). The DBSCAN algorithm performs poorly in comparison (",(0,i.jsx)(n.em,{children:"0.089"}),"). But the scoring system might fail us here."]}),"\n",(0,i.jsxs)(n.p,{children:["The sores we get from the ",(0,i.jsx)(n.strong,{children:"calinski_harabaz_score"})," are in line with this observation (k-means_score=1377.88, meanshift=1304.07, dbscan_sore=0.16)."]}),"\n",(0,i.jsx)(n.h1,{id:"supervised-learning-introduction",children:"Supervised Learning Introduction"}),"\n",(0,i.jsx)(n.p,{children:"A supervised model explores the relation between a set of features and a target value (label / class). E.g. a person's demographic and their ability to re-pay loans."}),"\n",(0,i.jsx)(n.h2,{id:"classification-tasks",children:"Classification Tasks"}),"\n",(0,i.jsx)(n.p,{children:"Classifications are used to build models with discrete categories as labels. Such tasks output a prediction as a probability of an instance belonging to a label. Common Classification Algorithms are:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Decision Trees"}),": A tree-like structure that simulates the decision process based on previous decisions."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Naive Bayes Classifier"}),": Relies on probabilistic equations which assume independence among features with the ability to consider several attributes."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Artificial Neutral Networks"}),": Replicate the structure of a biological neural network to perform pattern recognition tasks."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"regression-tasks",children:"Regression Tasks"}),"\n",(0,i.jsx)(n.p,{children:"Used for data with continuous quantities as labels, where the value is represented by a quantity and not a set of possible outcomes - e.g. a linear regression."}),"\n",(0,i.jsx)(n.h1,{id:"supervised-learning-irl",children:"Supervised Learning IRL"}),"\n",(0,i.jsx)(n.p,{children:"Finding an algorithm for a task is usually a process of trial & error using testing to validate the resulting model and comparing the result with results from other algorithms."}),"\n",(0,i.jsx)(n.h2,{id:"data-split",children:"Data Split"}),"\n",(0,i.jsx)(n.p,{children:"To avoid introducing bias into a supervised model, the data set is partitioned into 3 sets:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Training Set"}),": This set is used to train the models with different algorithms. It consists of input data paired with an outcome / label. It is ",(0,i.jsx)(n.em,{children:"not used"})," for performance evaluation of each model later on."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Validation Set"}),": This set is used to perform unbiased evaluations of each model and fine-tune parameters to achieve the best performance. The validation set therefore influences the training indirectly. In the end the model that performs the best is chosen to be used on the next set of data."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Testing Set"}),": This set consists of data that had no influence over the trained model and is used for a final, unbiased performance evaluation for future predictions by the model."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"Split Ratio"})," for those three sets depends on the size of our data set. For sets that contain ",(0,i.jsx)(n.em,{children:"100 - 100,000 instances"})," a split ration for training, validating, testing of ",(0,i.jsx)(n.em,{children:"60/20/20%"})," is used. For large data sets with ",(0,i.jsx)(n.em,{children:"more than a million instances"})," a split ration of ",(0,i.jsx)(n.em,{children:"98/1/1%"})," can be sufficient to determining the performance of a model."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.strong,{children:"Algorithm"})," also has an effect on the split ratio you have to use. E.g. if you are working with a model that has a lot of parameters, you might want to work with a larger validation set, while the testing set can remain small."]}),"\n",(0,i.jsx)(n.p,{children:"In the following we are using the Iris dataset from sklearn and load it into a Panda data frame. Printing the shape of the data frame, we can see that it consists of 150 rows and 4 columns of data and 1 column for the target value with 150 rows."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Python SciKit-Learn",src:t(299622).Z+"",width:"1182",height:"862"})}),"\n",(0,i.jsxs)(n.p,{children:["To split up our data in a training (",(0,i.jsx)(n.em,{children:"_train"}),"), validating (",(0,i.jsx)(n.em,{children:"_dev"}),") testing (",(0,i.jsx)(n.em,{children:"_test"}),") set, we can use the ",(0,i.jsx)(n.strong,{children:"train_test_split"})," method from sklearn. We are going to use a ",(0,i.jsx)(n.code,{children:"test_size"})," of ",(0,i.jsx)(n.code,{children:"0.2"})," - meaning that we are training our model with 80% of the data - which corresponds to 120 rows, while 30 rows are allocated for testing our model later on."]}),"\n",(0,i.jsx)(n.p,{children:"In a second step we need to subtract another portion of the data to from our validation group - which removes another 30 rows from our training data."}),"\n",(0,i.jsx)(n.h2,{id:"cross-validation",children:"Cross Validation"}),"\n",(0,i.jsxs)(n.p,{children:["To further reduce bias in our models we can further partition our data into ",(0,i.jsx)(n.strong,{children:"K"})," number of groups and re-sample data from those groups as we train and validate our model - this is called ",(0,i.jsx)(n.strong,{children:"K-fold Cross Validation"}),", where K is usually replaced by the number of samples used in the training process."]}),"\n",(0,i.jsx)(n.p,{children:"This process can replace the testing step discussed above or can be done in addition:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"three-split approach"}),": A testing set is subtracted from the data. The rest of the data is used in the cross-validation process."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"two-split approach"}),": The complete data set is used for cross-validation."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["In practice this process contains 4 steps that are repeated ",(0,i.jsx)(n.strong,{children:"K-times"}),":"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"First the data is shuffled."}),"\n",(0,i.jsx)(n.li,{children:"The data is split according to the process described above."}),"\n",(0,i.jsx)(n.li,{children:"The model is trained and the selected validation group is used to fine-tune parameters."}),"\n",(0,i.jsx)(n.li,{children:"The results from the training are stored and the process begins again with step 1 and is repeated K times."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"You end up with K data sets and a model that is trained K-times - the results refined with every iteration."}),"\n",(0,i.jsxs)(n.p,{children:["In the following we are going to use the same data set as before and use the ",(0,i.jsx)(n.strong,{children:"three-split-approach"})," by first removing 20% of our data to form a testing set. We then import the ",(0,i.jsx)(n.strong,{children:"KFold Method"})," from Sklearn to split our data in 10 subgroups:"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Python SciKit-Learn",src:t(197771).Z+"",width:"1181",height:"600"})}),"\n",(0,i.jsxs)(n.p,{children:["We now have a data set with 10 subgroups that can be referenced by an index number. We can use a ",(0,i.jsx)(n.em,{children:"for-loop"})," to iterate over the data."]}),"\n",(0,i.jsx)(n.h2,{id:"metric-evaluation",children:"Metric Evaluation"}),"\n",(0,i.jsx)(n.p,{children:"The accuracy of a model can be calculated as a percentage by comparing it's predicted values with real (unseen as not used in the training of the model) measurements."}),"\n",(0,i.jsxs)(n.p,{children:["This can visualized in the so called ",(0,i.jsx)(n.strong,{children:"Confusion Matrix"})," - a 2-dimensional matrix that contains the predictions as columns and the occurrence or non-occurrence of events as rows."]}),"\n",(0,i.jsx)(n.p,{children:"In the field of machine learning and specifically the problem of statistical classification, a confusion matrix, also known as an error matrix, is a specific table layout that allows visualization of the performance of an algorithm, typically a supervised learning one. Each row of the matrix represents the instances in a predicted class while each column represents the instances in an actual class (or vice versa)."}),"\n",(0,i.jsx)(n.p,{children:"If a classification system has been trained to distinguish between apples, oranges and pineapples, a confusion matrix will summarize the results of testing the algorithm for further inspection. Assuming a sample of 27 animals \u2014 8 apples, 6 oranges, and 13 pineapples, the resulting confusion matrix could look like the table below:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Prediction / Actual"}),(0,i.jsx)(n.th,{style:{textAlign:"center"},children:"Apple (A)"}),(0,i.jsx)(n.th,{style:{textAlign:"center"},children:"Orange (A)"}),(0,i.jsx)(n.th,{style:{textAlign:"center"},children:"Pineapple (A)"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Apple (P)"}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:(0,i.jsx)(n.strong,{children:"5"})}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"2"}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"0"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Orange (P)"}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"3"}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:(0,i.jsx)(n.strong,{children:"3"})}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"2"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Pineapple (P)"}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"0"}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:"1"}),(0,i.jsx)(n.td,{style:{textAlign:"center"},children:(0,i.jsx)(n.strong,{children:"11"})})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"In this confusion matrix, of the 8 actual apples, the system predicted that three were oranges, and of the six oranges, it predicted that one was a pineapple and two were apples. We can see from the matrix that the system in question has trouble distinguishing between apples and oranges, but can make the distinction between pineapples and other types of animals pretty well. All correct predictions are loaded in the diagonal of the table (highlighted in bold), so it is easy to visually inspect the table for prediction errors, as they will be represented by values outside the diagonal."}),"\n",(0,i.jsx)(n.h2,{id:"table-of-confusion",children:"Table of Confusion"}),"\n",(0,i.jsx)(n.p,{children:"In predictive analytics, a table of confusion (sometimes also called a confusion matrix), is a table with two rows and two columns that reports the number of false positives, false negatives, true positives, and true negatives. This allows more detailed analysis than mere proportion of correct classifications (accuracy). Accuracy is not a reliable metric for the real performance of a classifier, because it will yield misleading results if the data set is unbalanced (that is, when the numbers of observations in different classes vary greatly). For example, if there were 95 apples and only 5 oranges in the data, a particular classifier might classify all the observations as apples. The overall accuracy would be 95%, but in more detail the classifier would have a 100% recognition rate (sensitivity) for the apple class but a 0% recognition rate for the orange class."}),"\n",(0,i.jsx)(n.p,{children:"Assuming the confusion matrix above, its corresponding table of confusion, for the apple class, would be:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Prediction / Actual"}),(0,i.jsx)(n.th,{children:"Apple (A)"}),(0,i.jsx)(n.th,{children:"Not-Apple (A)"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Apple (P)"}),(0,i.jsx)(n.td,{children:"5 True Positives"}),(0,i.jsx)(n.td,{children:"2 False Positives"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Not-Apple (P)"}),(0,i.jsx)(n.td,{children:"3 False Negatives"}),(0,i.jsx)(n.td,{children:"17 True Negatives"})]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"evaluation-of-tasks-with-binary-output-labels",children:"Evaluation of Tasks with binary output labels"}),"\n",(0,i.jsx)(n.p,{children:"The performance of the model can be calculated based on the number of predictions that turned out to be true. The performance is given per feature (e.g. our model has a high accuracy to predict pineapples, but is a bit confused when it comes to distinguishing between apples and oranges). The performance table for a pineapple gives us the accuracy for the models prediction capabilities to recognize pineapples as follows:"}),"\n",(0,i.jsxs)(n.table,{children:[(0,i.jsx)(n.thead,{children:(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.th,{children:"Actual / Prediction"}),(0,i.jsx)(n.th,{children:"Pineapple (P)"}),(0,i.jsx)(n.th,{children:"Any other fruit (P)"}),(0,i.jsx)(n.th,{children:"Sum"}),(0,i.jsx)(n.th,{children:"Accuracy"})]})}),(0,i.jsxs)(n.tbody,{children:[(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Pineapple (A)"}),(0,i.jsx)(n.td,{children:"976"}),(0,i.jsx)(n.td,{children:"34"}),(0,i.jsx)(n.td,{children:"1000"}),(0,i.jsx)(n.td,{children:"97.6 %"})]}),(0,i.jsxs)(n.tr,{children:[(0,i.jsx)(n.td,{children:"Any other fruit (A)"}),(0,i.jsx)(n.td,{children:"157"}),(0,i.jsx)(n.td,{children:"843"}),(0,i.jsx)(n.td,{children:"1000"}),(0,i.jsx)(n.td,{children:"84.3 %"})]})]})]}),"\n",(0,i.jsx)(n.p,{children:"When the model saw a pineapple, out of 1000 instances it correctly predicted the type of fruit 976 times - giving us an accuracy of 97.6 %. But when seeing the image of an orange or apple it still concluded that it was a pineapple 157 times out of 1000 - resulting in an accuracy of 84.3 %."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Accuracy Metric"})," : To calculate the Accuracy of the model over all instances the sum of all ",(0,i.jsx)(n.strong,{children:"True Positives"})," and ",(0,i.jsx)(n.strong,{children:"True Negatives"})," is divided by the total number of instances: ",(0,i.jsx)(n.em,{children:"Accuracy = (TP + TN)/m"})]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Precision Metric"})," : To calculate the precision of model over all instances to classify positive binary labels we need to calculate: ",(0,i.jsx)(n.em,{children:"Precision = TP / (TP + FP)"})," e.g. (976) / (976 + 157) = 86.1%"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Recall Metric"})," : The recall metric is the number of correctly predicted positive labels against all correctly predicted labels, positive and negative: ",(0,i.jsx)(n.em,{children:"Recall = TP / (TP + FN)"})," e.g. (976) / (976 + 34) = 97.6%"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Python SciKit-Learn",src:t(422710).Z+"",width:"1139",height:"1085"})}),"\n",(0,i.jsx)(n.h3,{id:"evaluation-of-regression-tasks",children:"Evaluation of Regression Tasks"}),"\n",(0,i.jsx)(n.p,{children:"Regression tasks have continuous outputs without a fixed number of output labels - here we cannot use any of the metrics above to evaluate the accuracy or precision of the predictions of our model."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mean Absolute Error"})," : The MAE is the average distance between the predicted result and the actual value, without taking into account the direction of the error: ",(0,i.jsx)(n.em,{children:"MAE = 1/m * \u2211 (over all m instances) (y(actual) - y(predicted)"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Root Mean Square Error"})," : RMSE = \u221a (1/m * \u2211 (over all m instances) (y(actual) - y(predicted))\xb2"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["In both cases the ideal model (prediction = actual value) would result in an error of ",(0,i.jsx)(n.code,{children:"0"}),". In real applications you would try different models on your data and compare their prediction error - the one with the lowest error value wins."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Python SciKit-Learn",src:t(649248).Z+"",width:"1149",height:"1013"})})]})}function c(e={}){const{wrapper:n}={...(0,s.ah)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},603905:(e,n,t)=>{t.d(n,{ah:()=>h});var i=t(667294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,s=function(e,n){if(null==e)return{};var t,i,s={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var o=i.createContext({}),h=function(e){var n=i.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},c=i.forwardRef((function(e,n){var t=e.components,s=e.mdxType,a=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=h(t),p=s,m=u["".concat(o,".").concat(p)]||u[p]||d[p]||a;return t?i.createElement(m,r(r({ref:n},c),{},{components:t})):i.createElement(m,r({ref:n},c))}));c.displayName="MDXCreateElement"},284990:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/photo-33796028333_a7fa30ab08_o-c59d7b60abca3582796fbd0c7132d682.jpg"},246780:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/python-ml_01-b32c58e4ab112551197dafed7766a2bb.png"},576934:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/python-ml_02-4a8ed7c5a0b12a21cb92dafe5082075c.png"},780906:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/python-ml_03-55716561bd24d727414489bec67ab005.png"},649148:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/python-ml_04-0b0de1549b0c18119e77a656287529e2.png"},472538:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/python-ml_05-1047b7d4f8989a44599e6864f3cd010d.png"},868836:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/python-ml_06-dd7e0d9df21912cb0167df840e984d14.png"},606053:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/python-ml_07-a3836daef336dd3df85bb237a44461e3.png"},977562:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/python-ml_08-32fbcc8977c6082b1597ce7362a56fc5.png"},299622:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/python-ml_09-4ef7bb5476df94ab25d36d23051a8413.png"},197771:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/python-ml_10-e761a252eb62c598eb0f72999b1ba369.png"},422710:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/python-ml_11-47cbc3354547787ab12b49d157aeab59.png"},649248:(e,n,t)=>{t.d(n,{Z:()=>i});const i=t.p+"assets/images/python-ml_12-744f7e670042cd19a1f016b7bc796fd2.png"}}]);