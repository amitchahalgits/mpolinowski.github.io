"use strict";(self.webpackChunkmikes_dev_notebook=self.webpackChunkmikes_dev_notebook||[]).push([[99327],{3905:(A,e,n)=>{n.d(e,{Zo:()=>C,kt:()=>p});var a=n(67294);function t(A,e,n){return e in A?Object.defineProperty(A,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):A[e]=n,A}function r(A,e){var n=Object.keys(A);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(A);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(A,e).enumerable}))),n.push.apply(n,a)}return n}function i(A){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){t(A,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(A,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(A,e,Object.getOwnPropertyDescriptor(n,e))}))}return A}function o(A,e){if(null==A)return{};var n,a,t=function(A,e){if(null==A)return{};var n,a,t={},r=Object.keys(A);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||(t[n]=A[n]);return t}(A,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(A);for(a=0;a<r.length;a++)n=r[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(A,n)&&(t[n]=A[n])}return t}var s=a.createContext({}),l=function(A){var e=a.useContext(s),n=e;return A&&(n="function"==typeof A?A(e):i(i({},e),A)),n},C=function(A){var e=l(A.components);return a.createElement(s.Provider,{value:e},A.children)},g={inlineCode:"code",wrapper:function(A){var e=A.children;return a.createElement(a.Fragment,{},e)}},d=a.forwardRef((function(A,e){var n=A.components,t=A.mdxType,r=A.originalType,s=A.parentName,C=o(A,["components","mdxType","originalType","parentName"]),d=l(n),p=t,E=d["".concat(s,".").concat(p)]||d[p]||g[p]||r;return n?a.createElement(E,i(i({ref:e},C),{},{components:n})):a.createElement(E,i({ref:e},C))}));function p(A,e){var n=arguments,t=e&&e.mdxType;if("string"==typeof A||t){var r=n.length,i=new Array(r);i[0]=d;var o={};for(var s in e)hasOwnProperty.call(e,s)&&(o[s]=e[s]);o.originalType=A,o.mdxType="string"==typeof A?A:t,i[1]=o;for(var l=2;l<r;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},45424:(A,e,n)=>{n.r(e),n.d(e,{assets:()=>s,contentTitle:()=>i,default:()=>g,frontMatter:()=>r,metadata:()=>o,toc:()=>l});var a=n(87462),t=(n(67294),n(3905));const r={sidebar_position:4500,slug:"2023-03-26",title:"Tensorflow 2 - Unsupervised Learning",authors:"mpolinowski",tags:["Python","Machine Learning","Tensorflow"],description:"Generative Adverserial Networks for Image Data Generation"},i=void 0,o={unversionedId:"IoT-and-Machine-Learning/ML/2023-03-26-tensorflow-unsupervised-learning-generative-adversial-networks/index",id:"IoT-and-Machine-Learning/ML/2023-03-26-tensorflow-unsupervised-learning-generative-adversial-networks/index",title:"Tensorflow 2 - Unsupervised Learning",description:"Generative Adverserial Networks for Image Data Generation",source:"@site/docs/IoT-and-Machine-Learning/ML/2023-03-26-tensorflow-unsupervised-learning-generative-adversial-networks/index.md",sourceDirName:"IoT-and-Machine-Learning/ML/2023-03-26-tensorflow-unsupervised-learning-generative-adversial-networks",slug:"/IoT-and-Machine-Learning/ML/2023-03-26-tensorflow-unsupervised-learning-generative-adversial-networks/2023-03-26",permalink:"/docs/IoT-and-Machine-Learning/ML/2023-03-26-tensorflow-unsupervised-learning-generative-adversial-networks/2023-03-26",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/IoT-and-Machine-Learning/ML/2023-03-26-tensorflow-unsupervised-learning-generative-adversial-networks/index.md",tags:[{label:"Python",permalink:"/docs/tags/python"},{label:"Machine Learning",permalink:"/docs/tags/machine-learning"},{label:"Tensorflow",permalink:"/docs/tags/tensorflow"}],version:"current",sidebarPosition:4500,frontMatter:{sidebar_position:4500,slug:"2023-03-26",title:"Tensorflow 2 - Unsupervised Learning",authors:"mpolinowski",tags:["Python","Machine Learning","Tensorflow"],description:"Generative Adverserial Networks for Image Data Generation"},sidebar:"tutorialSidebar",previous:{title:"Principal Component Analysis (PCA)",permalink:"/docs/IoT-and-Machine-Learning/ML/2023-04-09-principal-component-analysis/2023-04-09"},next:{title:"Tensorflow 2 - Unsupervised Learning",permalink:"/docs/IoT-and-Machine-Learning/ML/2023-03-26-tensorflow-unsupervised-learning-autoencoders-super-resolution/2023-03-26"}},s={},l=[{value:"Generative Adverserial Networks",id:"generative-adverserial-networks",level:2},{value:"Dataset",id:"dataset",level:2},{value:"Create Batched Dataset",id:"create-batched-dataset",level:3},{value:"Building the Model",id:"building-the-model",level:2},{value:"Generator",id:"generator",level:3},{value:"Discriminator",id:"discriminator",level:3},{value:"Training the Model",id:"training-the-model",level:2},{value:"Making Predictions",id:"making-predictions",level:2},{value:"Dataset",id:"dataset-1",level:2},{value:"Create Batched Dataset",id:"create-batched-dataset-1",level:3},{value:"Building the Model",id:"building-the-model-1",level:2},{value:"Generator",id:"generator-1",level:3},{value:"Discriminator",id:"discriminator-1",level:3},{value:"Model Training",id:"model-training",level:2},{value:"Making Predictions",id:"making-predictions-1",level:2}],C={toc:l};function g(A){let{components:e,...r}=A;return(0,t.kt)("wrapper",(0,a.Z)({},C,r,{components:e,mdxType:"MDXLayout"}),(0,t.kt)("p",null,(0,t.kt)("img",{alt:"Victoria Harbour, Hongkong",src:n(70751).Z,width:"2385",height:"1054"})),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("a",{parentName:"li",href:"#tensorflow-unsupervised-learning"},"Tensorflow Unsupervised Learning"),(0,t.kt)("ul",{parentName:"li"},(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("a",{parentName:"li",href:"#generative-adverserial-networks"},"Generative Adverserial Networks")),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("a",{parentName:"li",href:"#dataset"},"Dataset"),(0,t.kt)("ul",{parentName:"li"},(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("a",{parentName:"li",href:"#create-batched-dataset"},"Create Batched Dataset")))),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("a",{parentName:"li",href:"#building-the-model"},"Building the Model"),(0,t.kt)("ul",{parentName:"li"},(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("a",{parentName:"li",href:"#generator"},"Generator")),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("a",{parentName:"li",href:"#discriminator"},"Discriminator")))),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("a",{parentName:"li",href:"#training-the-model"},"Training the Model")),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("a",{parentName:"li",href:"#making-predictions"},"Making Predictions")))),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("a",{parentName:"li",href:"#deep-convolutional-generative-adversarial-networks-dcgan"},"Deep Convolutional Generative Adversarial Networks (DCGAN)"),(0,t.kt)("ul",{parentName:"li"},(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("a",{parentName:"li",href:"#dataset-1"},"Dataset"),(0,t.kt)("ul",{parentName:"li"},(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("a",{parentName:"li",href:"#create-batched-dataset-1"},"Create Batched Dataset")))),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("a",{parentName:"li",href:"#building-the-model-1"},"Building the Model"),(0,t.kt)("ul",{parentName:"li"},(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("a",{parentName:"li",href:"#generator-1"},"Generator")),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("a",{parentName:"li",href:"#discriminator-1"},"Discriminator")))),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("a",{parentName:"li",href:"#model-training"},"Model Training")),(0,t.kt)("li",{parentName:"ul"},(0,t.kt)("a",{parentName:"li",href:"#making-predictions-1"},"Making Predictions"))))),(0,t.kt)("p",null,(0,t.kt)("a",{parentName:"p",href:"https://github.com/mpolinowski/tf-2023"},"Github Repository")),(0,t.kt)("p",null,(0,t.kt)("em",{parentName:"p"},"See also:")),(0,t.kt)("ul",null,(0,t.kt)("li",{parentName:"ul"},"Fun, fun, tensors: ",(0,t.kt)("a",{parentName:"li",href:"/docs/IoT-and-Machine-Learning/ML/2023-02-19-tensorflow-introduction/2023-02-19"},"Tensor Constants, Variables and Attributes"),", ",(0,t.kt)("a",{parentName:"li",href:"/docs/IoT-and-Machine-Learning/ML/2023-02-21-tensorflow-tensors-2/2023-02-21"},"Tensor Indexing, Expanding and Manipulations"),", ",(0,t.kt)("a",{parentName:"li",href:"/docs/IoT-and-Machine-Learning/ML/2023-02-22-tensorflow-tensors-3/2023-02-22"},"Matrix multiplications, Squeeze, One-hot and Numpy")),(0,t.kt)("li",{parentName:"ul"},"Tensorflow 2 - Neural Network Regression: ",(0,t.kt)("a",{parentName:"li",href:"/docs/IoT-and-Machine-Learning/ML/2023-02-23-tensorflow-neural-network-regression/2023-02-23"},"Building a Regression Model"),", ",(0,t.kt)("a",{parentName:"li",href:"/docs/IoT-and-Machine-Learning/ML/2023-02-24-tensorflow-neural-network-regression-evaluation/2023-02-24"},"Model Evaluation"),", ",(0,t.kt)("a",{parentName:"li",href:"/docs/IoT-and-Machine-Learning/ML/2023-02-25-tensorflow-neural-network-regression-experiments/2023-02-25"},"Model Optimization"),", ",(0,t.kt)("a",{parentName:"li",href:"/docs/IoT-and-Machine-Learning/ML/2023-02-26-tensorflow-neural-network-regression-real-dataset/2023-02-26"},'Working with a "Real" Dataset'),", ",(0,t.kt)("a",{parentName:"li",href:"/docs/IoT-and-Machine-Learning/ML/2023-02-26-tensorflow-neural-network-regression-data-preprocessing/2023-02-26"},"Feature Scaling")),(0,t.kt)("li",{parentName:"ul"},"Tensorflow 2 - Neural Network Classification: ",(0,t.kt)("a",{parentName:"li",href:"/docs/IoT-and-Machine-Learning/ML/2023-02-27-tensorflow-neural-network-classification/2023-02-27"},"Non-linear Data and Activation Functions"),", ",(0,t.kt)("a",{parentName:"li",href:"/docs/IoT-and-Machine-Learning/ML/2023-02-28-tensorflow-neural-network-classification-model-evaluation/2023-02-28"},"Model Evaluation and Performance Improvement"),", ",(0,t.kt)("a",{parentName:"li",href:"/docs/IoT-and-Machine-Learning/ML/2023-03-02-tensorflow-neural-network-multi-classification/2023-03-02"},"Multiclass Classification Problems")),(0,t.kt)("li",{parentName:"ul"},"Tensorflow 2 - Convolutional Neural Networks: ",(0,t.kt)("a",{parentName:"li",href:"/docs/IoT-and-Machine-Learning/ML/2023-03-03-tensorflow-convolutional-neural-network-binary-classifications/2023-03-03"},"Binary Image Classification"),", ",(0,t.kt)("a",{parentName:"li",href:"/docs/IoT-and-Machine-Learning/ML/2023-03-05-tensorflow-convolutional-neural-network-multiclass-classifications/2023-03-05"},"Multiclass Image Classification")),(0,t.kt)("li",{parentName:"ul"},"Tensorflow 2 - Transfer Learning: ",(0,t.kt)("a",{parentName:"li",href:"/docs/IoT-and-Machine-Learning/ML/2023-03-06-tensorflow-transfer-learning-feature-extraction/2023-03-06"},"Feature Extraction"),", ",(0,t.kt)("a",{parentName:"li",href:"/docs/IoT-and-Machine-Learning/ML/2023-03-11-tensorflow-transfer-learning-fine-tuning/2023-03-11"},"Fine-Tuning"),", ",(0,t.kt)("a",{parentName:"li",href:"/docs/IoT-and-Machine-Learning/ML/2023-03-16-tensorflow-transfer-learning-scaling/2023-03-16"},"Scaling")),(0,t.kt)("li",{parentName:"ul"},"Tensorflow 2 - Unsupervised Learning: ",(0,t.kt)("a",{parentName:"li",href:"/docs/IoT-and-Machine-Learning/ML/2023-03-24-tensorflow-unsupervised-learning-autoencoders/2023-03-24"},"Autoencoder Feature Detection"),", ",(0,t.kt)("a",{parentName:"li",href:"/docs/IoT-and-Machine-Learning/ML/2023-03-26-tensorflow-unsupervised-learning-autoencoders-super-resolution/2023-03-26"},"Autoencoder Super-Resolution"),", ",(0,t.kt)("a",{parentName:"li",href:"/docs/IoT-and-Machine-Learning/ML/2023-03-26-tensorflow-unsupervised-learning-generative-adversial-networks/2023-03-26"},"Generative Adverserial Networks"))),(0,t.kt)("h1",{id:"tensorflow-unsupervised-learning"},"Tensorflow Unsupervised Learning"),(0,t.kt)("h2",{id:"generative-adverserial-networks"},"Generative Adverserial Networks"),(0,t.kt)("p",null,"GANs are a framework for teaching a DL model to capture the training data\u2019s distribution so we can generate new data from that same distribution."),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"import matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport tensorflow as tf\nfrom tensorflow.keras.datasets import mnist\nfrom tensorflow.keras.layers import Dense,Reshape,Dropout,LeakyReLU,Flatten,BatchNormalization,Conv2D,Conv2DTranspose\nfrom tensorflow.keras.models import Sequential\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"SEED = 42\nINPUT_SHAPE = 100\nBATCH_SIZE = 32\nEPOCHS = 25\n")),(0,t.kt)("h2",{id:"dataset"},"Dataset"),(0,t.kt)("p",null,'Using a GAN to generate "fake" MNIST digit images.'),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"# setting up the dataset\n(X_train, y_train), (X_test, y_test) = mnist.load_data()\n\nplt.imshow(X_train[8888])\nplt.title(y_train[8888])\nplt.show()\n")),(0,t.kt)("p",null,(0,t.kt)("img",{alt:"Generative Adverserial Networks",src:n(13422).Z,width:"416",height:"435"})),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"# to speed up the training we can pre-select\n# only images with label `3`\nX_train_three = X_train[y_train==3]\nprint(X_train_three.shape)\n# there are 6131 images that represent the digit 3\n# (6131, 28, 28)\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"# plot results\nplt.figure(figsize=(12, 12))\n# ROW 1\nplt.subplot(3, 3, 1)\nplt.axis(False)\nplt.imshow(X_train_three[1])\nplt.subplot(3, 3, 2)\nplt.axis(False)\nplt.imshow(X_train_three[2])\nplt.subplot(3, 3, 3)\nplt.axis(False)\nplt.imshow(X_train_three[3])\n# ROW 2\nplt.subplot(3, 3, 4)\nplt.axis(False)\nplt.imshow(X_train_three[4])\nplt.subplot(3, 3, 5)\nplt.axis(False)\nplt.imshow(X_train_three[5])\nplt.subplot(3, 3, 6)\nplt.axis(False)\nplt.imshow(X_train_three[6])\n# ROW 3\nplt.subplot(3, 3, 7)\nplt.axis(False)\nplt.imshow(X_train_three[7])\nplt.subplot(3, 3, 8)\nplt.axis(False)\nplt.imshow(X_train_three[8])\nplt.subplot(3, 3, 9)\nplt.axis(False)\nplt.imshow(X_train_three[9])\n")),(0,t.kt)("p",null,(0,t.kt)("img",{alt:"Generative Adverserial Networks",src:n(33648).Z,width:"948",height:"944"})),(0,t.kt)("h3",{id:"create-batched-dataset"},"Create Batched Dataset"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"dataset = tf.data.Dataset.from_tensor_slices(X_train_three).shuffle(buffer_size=1000)\ndataset = dataset.batch(BATCH_SIZE, drop_remainder=True).prefetch(1)\n")),(0,t.kt)("h2",{id:"building-the-model"},"Building the Model"),(0,t.kt)("h3",{id:"generator"},"Generator"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},'tf.random.set_seed(SEED)\n\ngenerator = Sequential(name="generator")\ngenerator.add(Dense(100, activation="relu", input_shape=[INPUT_SHAPE]))\ngenerator.add(Dense(150,activation=\'relu\'))\ngenerator.add(Dense(784, activation="sigmoid")) # 28*28 = 784\ngenerator.add(Reshape([28,28]))\n')),(0,t.kt)("h3",{id:"discriminator"},"Discriminator"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},'discriminator = Sequential(name="discriminator")\ndiscriminator.add(Flatten(input_shape=[28,28]))\ndiscriminator.add(Dense(150,activation=\'relu\'))\ndiscriminator.add(Dense(100,activation=\'relu\'))\ndiscriminator.add(Dense(1,activation="sigmoid"))\n\ndiscriminator.compile(loss="binary_crossentropy", optimizer="adam")\ndiscriminator.trainable = False\n')),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},'GAN = Sequential([generator, discriminator])\n\nGAN.compile(loss="binary_crossentropy", optimizer="adam")\n\nGAN.summary()\n\n# Model: "sequential"\n# _________________________________________________________________\n#  Layer (type)                Output Shape              Param #   \n# =================================================================\n#  generator (Sequential)      (None, 28, 28)            143634    \n                                                                 \n#  discriminator (Sequential)  (None, 1)                 132951    \n                                                                 \n# =================================================================\n# Total params: 276,585\n# Trainable params: 143,634\n# Non-trainable params: 132,951\n# _________________________________________________________________\n')),(0,t.kt)("h2",{id:"training-the-model"},"Training the Model"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},'# Grab the seprate components\ngenerator, discriminator = GAN.layers\n\n# For every epcoh\nfor epoch in range(EPOCHS):\n    print(f"INFO :: Epoch: {epoch+1}")\n    i = 0\n    # For every batch in the dataset\n    for X_batch in dataset:\n        i=i+1\n        if i%100 == 0:\n            print(f"\\tBatch number: {i} of {len(X_train_three)//BATCH_SIZE}")\n        #####################################\n        ## TRAINING THE DISCRIMINATOR ######\n        ###################################\n        \n        # Create Noise\n        noise = tf.random.normal(shape=[BATCH_SIZE, INPUT_SHAPE])\n        \n        # Generate numbers based just on noise input\n        gen_images = generator(noise)\n        \n        # Concatenate Generated Images against the Real Ones\n        # TO use tf.concat, the data types must match!\n        X_fake_vs_real = tf.concat([gen_images, tf.dtypes.cast(X_batch,tf.float32)], axis=0)\n        \n        # Targets set to zero for fake images and 1 for real images\n        y1 = tf.constant([[0.]] * BATCH_SIZE + [[1.]] * BATCH_SIZE)\n        \n        # This gets rid of a Keras warning\n        discriminator.trainable = True\n        \n        # Train the discriminator on this batch\n        discriminator.train_on_batch(X_fake_vs_real, y1)\n        \n        \n        #####################################\n        ## TRAINING THE GENERATOR     ######\n        ###################################\n        \n        # Create some noise\n        noise = tf.random.normal(shape=[BATCH_SIZE, INPUT_SHAPE])\n        \n        # We want discriminator to belive that fake images are real\n        y2 = tf.constant([[1.]] * BATCH_SIZE)\n        \n        # Avois a warning\n        discriminator.trainable = False\n        \n        GAN.train_on_batch(noise, y2)\n        \nprint("INFO :: Training Completed")\n')),(0,t.kt)("h2",{id:"making-predictions"},"Making Predictions"),(0,t.kt)("p",null,"The Generator expects a noise input tensor with input shape = INPUT_SHAPE. To have the Generator create an image - based on the previous training - we have to input such tensor of beautiful randomness."),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"# generate noise for 10 images\nnoise_input = tf.random.normal(shape=[10, INPUT_SHAPE])\n\nprint(noise_input.shape)\n# (10, 100)\nplt.imshow(noise_input)\n")),(0,t.kt)("p",null,(0,t.kt)("img",{alt:"Generative Adverserial Networks",src:n(87682).Z,width:"534",height:"96"})),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"generated_images = generator(noise_input)\ngenerated_images.shape\n# TensorShape([10, 28, 28])\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"# plot results\nplt.figure(figsize=(12, 12))\n# ROW 1\nplt.subplot(3, 3, 1)\nplt.axis(False)\nplt.imshow(generated_images[0])\nplt.subplot(3, 3, 2)\nplt.axis(False)\nplt.imshow(generated_images[1])\nplt.subplot(3, 3, 3)\nplt.axis(False)\nplt.imshow(generated_images[2])\n# ROW 2\nplt.subplot(3, 3, 4)\nplt.axis(False)\nplt.imshow(generated_images[3])\nplt.subplot(3, 3, 5)\nplt.axis(False)\nplt.imshow(generated_images[4])\nplt.subplot(3, 3, 6)\nplt.axis(False)\nplt.imshow(generated_images[5])\n# ROW 3\nplt.subplot(3, 3, 7)\nplt.axis(False)\nplt.imshow(generated_images[6])\nplt.subplot(3, 3, 8)\nplt.axis(False)\nplt.imshow(generated_images[7])\nplt.subplot(3, 3, 9)\nplt.axis(False)\nplt.imshow(generated_images[8])\n")),(0,t.kt)("p",null,(0,t.kt)("img",{alt:"Generative Adverserial Networks",src:n(31330).Z,width:"948",height:"944"})),(0,t.kt)("p",null,"Why do all generated ",(0,t.kt)("inlineCode",{parentName:"p"},"3"),"'s look the same? => ",(0,t.kt)("a",{parentName:"p",href:"https://arxiv.org/abs/2012.09673"},"Combating Mode Collapse in GAN training: An Empirical Analysis using Hessian Eigenvalues")),(0,t.kt)("h1",{id:"deep-convolutional-generative-adversarial-networks-dcgan"},"Deep Convolutional Generative Adversarial Networks (DCGAN)"),(0,t.kt)("p",null,"A DCGAN is a direct extension of the GAN described above, except that it explicitly uses convolutional and convolutional-transpose layers in the discriminator and generator, respectively. It was first described by Radford et. al. in the paper ",(0,t.kt)("a",{parentName:"p",href:"https://arxiv.org/pdf/1511.06434.pdf"},"Unsupervised Representation Learning With Deep Convolutional Generative Adversarial Networks"),"."),(0,t.kt)("p",null,"The ",(0,t.kt)("strong",{parentName:"p"},"Discriminator")," is made up of strided convolution layers, batch norm layers, and LeakyReLU activations. The input is a 3x64x64 input image and the output is a scalar probability that the input is from the real data distribution."),(0,t.kt)("p",null,"The ",(0,t.kt)("strong",{parentName:"p"},"Generator")," is comprised of convolutional-transpose layers, batch norm layers, and ReLU activations. The input is a latent vector, ","(","z",")",", that is drawn from a standard normal distribution and the output is a 3x64x64 RGB image. The strided conv-transpose layers allow the latent vector to be transformed into a volume with the same shape as an image."),(0,t.kt)("h2",{id:"dataset-1"},"Dataset"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"# Generator will use tanh activation function for the last layer,\n# so we want to reshape X_train to be within -1 to 1 limits\nX_train_norm = X_train/255\nX_train_reshaped = X_train_norm.reshape(-1, 28, 28, 1) * 2. - 1.\n\nprint(X_train_norm.shape, X_train_reshaped.shape, X_train_reshaped.min(), X_train_reshaped.max())\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"# only images with label `3`\nX_train_three_dcgan = X_train_reshaped[y_train==3]\nprint(X_train_three_dcgan.shape)\n# (6131, 28, 28, 1)\n")),(0,t.kt)("h3",{id:"create-batched-dataset-1"},"Create Batched Dataset"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"dataset = tf.data.Dataset.from_tensor_slices(X_train_three_dcgan).shuffle(buffer_size=1000)\ndataset = dataset.batch(BATCH_SIZE, drop_remainder=True).prefetch(1)\n")),(0,t.kt)("h2",{id:"building-the-model-1"},"Building the Model"),(0,t.kt)("h3",{id:"generator-1"},"Generator"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},'tf.random.set_seed(SEED)\n\ngenerator = Sequential()\ngenerator.add(Dense(7 * 7 * 128, input_shape=[INPUT_SHAPE]))\ngenerator.add(Reshape([7, 7, 128]))\ngenerator.add(BatchNormalization())\ngenerator.add(Conv2DTranspose(64, kernel_size=5, strides=2, padding="same",\n                                 activation="relu"))\ngenerator.add(BatchNormalization())\ngenerator.add(Conv2DTranspose(1, kernel_size=5, strides=2, padding="same",\n                                 activation="tanh"))\n')),(0,t.kt)("h3",{id:"discriminator-1"},"Discriminator"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},'discriminator = Sequential()\ndiscriminator.add(Conv2D(64, kernel_size=5, strides=2, padding="same",\n                        activation=LeakyReLU(0.3),\n                        input_shape=[28, 28, 1]))\ndiscriminator.add(Dropout(0.5))\ndiscriminator.add(Conv2D(128, kernel_size=5, strides=2, padding="same",\n                        activation=LeakyReLU(0.3)))\ndiscriminator.add(Dropout(0.5))\ndiscriminator.add(Flatten())\ndiscriminator.add(Dense(1, activation="sigmoid"))\n\ndiscriminator.compile(loss="binary_crossentropy", optimizer="adam")\ndiscriminator.trainable = False\n')),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},'GAN = Sequential([generator, discriminator])\nGAN.compile(loss="binary_crossentropy", optimizer="adam")\nGAN.summary()\n\n# Model: "sequential_4"\n# _________________________________________________________________\n#  Layer (type)                Output Shape              Param #   \n# =================================================================\n#  sequential_1 (Sequential)   (None, 28, 28, 1)         840705    \n                                                                 \n#  sequential_3 (Sequential)   (None, 1)                 212865    \n                                                                 \n# =================================================================\n# Total params: 1,053,570\n# Trainable params: 840,321\n# Non-trainable params: 213,249\n# _________________________________________________________________\n')),(0,t.kt)("h2",{id:"model-training"},"Model Training"),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},'# Grab the seprate components\ngenerator, discriminator = GAN.layers\n\n# For every epcoh\nfor epoch in range(EPOCHS):\n    print(f"INFO :: Epoch: {epoch+1}")\n    i = 0\n    # For every batch in the dataset\n    for X_batch in dataset:\n        i=i+1\n        if i%20 == 0:\n            print(f"\\tBatch number: {i} of {len(X_train_three)//BATCH_SIZE}")\n        #####################################\n        ## TRAINING THE DISCRIMINATOR ######\n        ###################################\n        \n        # Create Noise\n        noise = tf.random.normal(shape=[BATCH_SIZE, INPUT_SHAPE])\n        \n        # Generate numbers based just on noise input\n        gen_images = generator(noise)\n        \n        # Concatenate Generated Images against the Real Ones\n        # TO use tf.concat, the data types must match!\n        X_fake_vs_real = tf.concat([gen_images, tf.dtypes.cast(X_batch,tf.float32)], axis=0)\n        \n        # Targets set to zero for fake images and 1 for real images\n        y1 = tf.constant([[0.]] * BATCH_SIZE + [[1.]] * BATCH_SIZE)\n        \n        # This gets rid of a Keras warning\n        discriminator.trainable = True\n        \n        # Train the discriminator on this batch\n        discriminator.train_on_batch(X_fake_vs_real, y1)\n        \n        \n        #####################################\n        ## TRAINING THE GENERATOR     ######\n        ###################################\n        \n        # Create some noise\n        noise = tf.random.normal(shape=[BATCH_SIZE, INPUT_SHAPE])\n        \n        # We want discriminator to belive that fake images are real\n        y2 = tf.constant([[1.]] * BATCH_SIZE)\n        \n        # Avois a warning\n        discriminator.trainable = False\n        \n        GAN.train_on_batch(noise, y2)\n        \nprint("TRAINING COMPLETE")            \n')),(0,t.kt)("h2",{id:"making-predictions-1"},"Making Predictions"),(0,t.kt)("p",null,"The Generator expects a noise input tensor with input shape = INPUT_SHAPE. To have the Generator create an image - based on the previous training - we have to input such tensor of beautiful randomness."),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"# generate noise for 10 images\nnoise_input = tf.random.normal(shape=[10, INPUT_SHAPE])\n\nprint(noise_input.shape)\n# (10, 100)\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"generated_images = generator(noise_input)\ngenerated_images.shape\n# TensorShape([10, 28, 28])\n")),(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-python"},"# plot results\nplt.figure(figsize=(12, 12))\n# ROW 1\nplt.subplot(3, 3, 1)\nplt.axis(False)\nplt.imshow(generated_images[0])\nplt.subplot(3, 3, 2)\nplt.axis(False)\nplt.imshow(generated_images[1])\nplt.subplot(3, 3, 3)\nplt.axis(False)\nplt.imshow(generated_images[2])\n# ROW 2\nplt.subplot(3, 3, 4)\nplt.axis(False)\nplt.imshow(generated_images[3])\nplt.subplot(3, 3, 5)\nplt.axis(False)\nplt.imshow(generated_images[4])\nplt.subplot(3, 3, 6)\nplt.axis(False)\nplt.imshow(generated_images[5])\n# ROW 3\nplt.subplot(3, 3, 7)\nplt.axis(False)\nplt.imshow(generated_images[6])\nplt.subplot(3, 3, 8)\nplt.axis(False)\nplt.imshow(generated_images[7])\nplt.subplot(3, 3, 9)\nplt.axis(False)\nplt.imshow(generated_images[8])\n")),(0,t.kt)("p",null,(0,t.kt)("img",{alt:"Generative Adverserial Networks",src:n(43519).Z,width:"948",height:"944"})))}g.isMDXComponent=!0},13422:(A,e,n)=>{n.d(e,{Z:()=>a});const a="data:image/png;base64,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"},33648:(A,e,n)=>{n.d(e,{Z:()=>a});const a=n.p+"assets/images/05_Tensorflow_Unsupervised_Learning_20-53f88093d0f507a32a5ac9fff92cd9b8.png"},87682:(A,e,n)=>{n.d(e,{Z:()=>a});const a="data:image/png;base64,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"},31330:(A,e,n)=>{n.d(e,{Z:()=>a});const a="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA7QAAAOwCAYAAAAOVji4AAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjYuMiwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8o6BhiAAAACXBIWXMAAA9hAAAPYQGoP6dpAAAmW0lEQVR4nO3dQahk2X3f8arXpekwgwyOQxb1FMfyKkqwXNNC2MRexCbtktuybAhNHAhkYQTGJJuss8w6m4RsBkEgkBg3XkiMul/RNjaJJTzW9HShYCyhIW215tUiYBlkLDxj9btZDUy1e7pOVZ9b5/5ufT7rw7nn1a3609++izvtuq6bAAAAQJiz1gcAAACAQwhaAAAAIglaAAAAIglaAAAAIglaAAAAIglaAAAAIglaAAAAIglaAAAAIglaAAAAIs1KF948u93nOYARu391p/URemU+AocyHwGerXQ+ekILAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABAJEELAABApFnrA4zdarPeuWY5X1Tbax8P3n1v55pPXX+paK/SvwHgfUOejxffv75zzWdefrdoL/MR2FfN+Xj38q2iddemZc+5Pv7lz+9c8+iXXivay3ykBk9oAQAAiCRoAQAAiCRoAQAAiCRoAQAAiCRoAQAAiCRoAQAAiCRoAQAAiCRoAQAAiCRoAQAAiDRrfYBjWm3WO9cs54vez3Go2mcr+Txa7FWqxecx5O8HvIj077/5uM18hHrSv/+3zm9U3e/R5rVqe5mP1OAJLQAAAJEELQAAAJEELQAAAJEELQAAAJEELQAAAJEELQAAAJEELQAAAJEELQAAAJFmrQ+QqvRF0DVfpNzi5dO1lXwetf/OmveqxX2HNObjYcxHGD/z8TDmI8/jCS0AAACRBC0AAACRBC0AAACRBC0AAACRBC0AAACRBC0AAACR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AEQStAAAAESatT4A5VabddG65XzR6zleRM2zle5V+rkN1RjuO/RtDL8T83F/Y7jv0Lcx/E7Mx/2N4b6X8oQWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASLPWBzimL11+beeaX/w3v1G010d+98GLHmdvy/ni6NekX6vNeuca951jKPku/tI//VzRXj/4s8cveJr9+Z2Mj/nIUNy9fGvnms/9zK8W7WU+UoP5uM0TWgAAACIJWgAAACIJWgAAACIJWgAAACIJWgAAACIJWgAAACIJWgAAACIJWgAAACLNWh/gmD53/umda66/8o2iva4Kr1nzxccle+2zXwtXP7vYueb+b/+33s8BbCuaG9PvVL2m+bhtdj7fuebLX7t7hJMAH3Tr/MbONdPZpuo1zcdtZz/5iZ1r7t37n0c4CUPkCS0AAACRBC0AAACRBC0AAACRBC0AAACRBC0AAACRBC0AAACRBC0AAACRBC0AAACRBC0AAACRZq0PMDT3vvWVqvst54uda1abddVr1tyv5Pz7XHM5r3fNUrU/3xK1/wYYgtXlw6r7mY9P71fvmqXMR6jj4vGbVfczH5/er941S5mPOTyhBQAAIJKgBQAAIJKgBQAAIJKgBQAAIJKgBQAAIJKgBQAAIJKgBQAAIJKgBQAAIJKgBQAAINKs9QGGZnn+atnCruv3IM+wnC+K1q0262rXrLlXH/uVqPm5lX4/VpuHRetKzwZDMOTvq/l4mKrzsfI9GPL3DZ425O+r+XgY8zGHJ7QAAABEErQAAABEErQAAABEErQAAABEErQAAABEErQAAABEErQAAABEErQAAABEmrU+wOB0XesTjFqLF0HXfUl12ffDC6+BfeXPxzLmI7Av85Hn8YQWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASLPWB2AyWc4XRetWm3WT65YoPVvJutqfR82/Ezgu83Gb+Qi8z3zcZj6eLk9oAQAAiCRoAQAAiCRoAQAAiCRoAQAAiCRoAQAAiCRoAQAAiCRoAQAAiCRoAQAAiCRoAQAAiDTtuq4rWXjz7HbfZwFG6v7VndZH6JX5CBzKfAR4ttL56AktAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkQQtAAAAkaZd13WtDwEAAAD78oQWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASIIWAACASLPShTfPbvd5DmDE7l/daX2EXpmPwKHMR4BnK52PntACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQSdACAAAQadb6AGO32qx3rlnOF0V7fenya0Xrrk8/UrTu5/7kV3au+f1/8sWivUr/BoD31ZyPJXvt4z//xT/cuebf/fC3i/YyH4F91ZyPdy/fKlp3bVr2nOvjr39+55pHn32taC/zkRo8oQUAACCSoAUAACCSoAUAACCSoAUAACCSoAUAACCSoAUAACCSoAUAACCSoAUAACCSoAUAACDSrPUBjmm1We9cs5wvej/HoT53/umq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"},43519:(A,e,n)=>{n.d(e,{Z:()=>a});const a=n.p+"assets/images/05_Tensorflow_Unsupervised_Learning_23-68eb97eeaf63b22764c3c0dd4bccddc5.png"},70751:(A,e,n)=>{n.d(e,{Z:()=>a});const a=n.p+"assets/images/photo-kt443t6d_64hdh43hfh6dgjdfhg4_d-da0f4433cfd061cf6ed148c34ca4eb14.jpg"}}]);