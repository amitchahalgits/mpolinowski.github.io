"use strict";(self.webpackChunkmikes_dev_notebook=self.webpackChunkmikes_dev_notebook||[]).push([[75886],{453062:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>d,default:()=>o,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var t=n(785893),s=n(603905);const r={sidebar_position:4750,slug:"2023-01-30",title:"SciKit Wine Quality",authors:"mpolinowski",tags:["Python","Machine Learning","SciKit"],description:"Predicting Wine Quality with Several Classification Techniques using SciKit Learn."},d=void 0,a={id:"IoT-and-Machine-Learning/ML/2023-01-30-predicting-wine-quality/index",title:"SciKit Wine Quality",description:"Predicting Wine Quality with Several Classification Techniques using SciKit Learn.",source:"@site/docs/IoT-and-Machine-Learning/ML/2023-01-30-predicting-wine-quality/index.md",sourceDirName:"IoT-and-Machine-Learning/ML/2023-01-30-predicting-wine-quality",slug:"/IoT-and-Machine-Learning/ML/2023-01-30-predicting-wine-quality/2023-01-30",permalink:"/docs/IoT-and-Machine-Learning/ML/2023-01-30-predicting-wine-quality/2023-01-30",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/IoT-and-Machine-Learning/ML/2023-01-30-predicting-wine-quality/index.md",tags:[{label:"Python",permalink:"/docs/tags/python"},{label:"Machine Learning",permalink:"/docs/tags/machine-learning"},{label:"SciKit",permalink:"/docs/tags/sci-kit"}],version:"current",sidebarPosition:4750,frontMatter:{sidebar_position:4750,slug:"2023-01-30",title:"SciKit Wine Quality",authors:"mpolinowski",tags:["Python","Machine Learning","SciKit"],description:"Predicting Wine Quality with Several Classification Techniques using SciKit Learn."},sidebar:"tutorialSidebar",previous:{title:"Keras for Tensorflow - An (Re)Introduction 2023",permalink:"/docs/IoT-and-Machine-Learning/ML/2023-02-14-keras-introduction/2023-02-14"},next:{title:"OpenCV Count My Money",permalink:"/docs/IoT-and-Machine-Learning/ML/2023-01-28-opencv-coin-counter/2023-01-28"}},l={},c=[{value:"Dataset Exploration",id:"dataset-exploration",level:2},{value:"Feature Importance",id:"feature-importance",level:3},{value:"Red Wines",id:"red-wines",level:4},{value:"White Wines",id:"white-wines",level:4},{value:"Data Pre-Processing",id:"data-pre-processing",level:2},{value:"Binary Classification",id:"binary-classification",level:3},{value:"Data Normalization",id:"data-normalization",level:3},{value:"Data Splitting",id:"data-splitting",level:3},{value:"Fitting a Model",id:"fitting-a-model",level:2},{value:"Decision Tree",id:"decision-tree",level:3},{value:"Random Forest",id:"random-forest",level:3},{value:"AdaBoost",id:"adaboost",level:3},{value:"Gradient Boosting",id:"gradient-boosting",level:3},{value:"XGBoost",id:"xgboost",level:3}];function h(e){const i={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.ah)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"Guangzhou, China",src:n(685287).Z+"",width:"2385",height:"883"})}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"#dataset-exploration",children:"Dataset Exploration"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"#feature-importance",children:"Feature Importance"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#red-wines",children:"Red Wines"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#white-wines",children:"White Wines"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"#data-pre-processing",children:"Data Pre-Processing"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#binary-classification",children:"Binary Classification"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#data-normalization",children:"Data Normalization"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#data-splitting",children:"Data Splitting"})}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.a,{href:"#fitting-a-model",children:"Fitting a Model"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#decision-tree",children:"Decision Tree"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#random-forest",children:"Random Forest"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#adaboost",children:"AdaBoost"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#gradient-boosting",children:"Gradient Boosting"})}),"\n",(0,t.jsx)(i.li,{children:(0,t.jsx)(i.a,{href:"#xgboost",children:"XGBoost"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.a,{href:"https://github.com/mpolinowski/scikit-wine-quality",children:"Github Repository"})}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsxs)(i.p,{children:["Based on ",(0,t.jsx)(i.a,{href:"https://www.kaggle.com/datasets/uciml/red-wine-quality-cortez-et-al-2009",children:"Red Wine Quality"}),", ",(0,t.jsx)(i.em,{children:"Simple and clean practice dataset for regression or classification modelling"})]}),"\n"]}),"\n",(0,t.jsxs)(i.blockquote,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Source"}),": The two datasets are related to red and white variants of the Portuguese ",(0,t.jsx)(i.a,{href:"http://www.vinhoverde.pt/en/",children:"Vinho Verde"})," wine. For more details, consult the reference ",(0,t.jsx)(i.a,{href:"https://archive.ics.uci.edu/ml/datasets/wine+quality",children:"Cortez et al., 2009"}),". Due to privacy and logistic issues, only physicochemical (inputs) and sensory (the output) variables are available (e.g. there is no data about grape types, wine brand, wine selling price, etc.)."]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"dataset-exploration",children:"Dataset Exploration"}),"\n",(0,t.jsx)(i.p,{children:"The quality of a wine is determined by 11 input variables:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Fixed acidity"}),"\n",(0,t.jsx)(i.li,{children:"Volatile acidity"}),"\n",(0,t.jsx)(i.li,{children:"Citric acid"}),"\n",(0,t.jsx)(i.li,{children:"Residual sugar"}),"\n",(0,t.jsx)(i.li,{children:"Chlorides"}),"\n",(0,t.jsx)(i.li,{children:"Free sulfur dioxide"}),"\n",(0,t.jsx)(i.li,{children:"Total sulfur dioxide"}),"\n",(0,t.jsx)(i.li,{children:"Density"}),"\n",(0,t.jsx)(i.li,{children:"pH"}),"\n",(0,t.jsx)(i.li,{children:"Sulfates"}),"\n",(0,t.jsx)(i.li,{children:"Alcohol"}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"Start by downloading the dataset:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-bash",children:"mkdir data\nwget --directory-prefix=data https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality.names\nwget --directory-prefix=data https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-red.csv\nwget --directory-prefix=data https://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality-white.csv\n"})}),"\n",(0,t.jsx)(i.p,{children:"And take a look at it:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-bash",children:'df = pd.read_csv("data/winequality-red.csv")\n\n# See the number of rows and columns\nprint("Rows, columns: " + str(df.shape))\n## Rows, columns: (1599, 1)\n\n# Missing Values\nprint(df.isna().sum())\n# fixed acidity;"volatile acidity";"citric acid";"residual sugar";"chlorides";"free sulfur dioxide";"total sulfur dioxide";"density";"pH";"sulphates";"alcohol";"quality"    0 <- nothing missing\n# dtype: int64\n'})}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-py",children:"# See the first five rows of the dataset\nprint(df.head())\n"})}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{children:"fixed acidity"}),(0,t.jsx)(i.th,{children:"volatile acidity"}),(0,t.jsx)(i.th,{children:"citric acid"}),(0,t.jsx)(i.th,{children:"residual sugar"}),(0,t.jsx)(i.th,{children:"chlorides"}),(0,t.jsx)(i.th,{children:"free sulfur dioxide"}),(0,t.jsx)(i.th,{children:"total sulfur dioxide"}),(0,t.jsx)(i.th,{children:"density"}),(0,t.jsx)(i.th,{children:"pH"}),(0,t.jsx)(i.th,{children:"sulphates"}),(0,t.jsx)(i.th,{children:"alcohol"}),(0,t.jsx)(i.th,{children:"quality"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"7.4"}),(0,t.jsx)(i.td,{children:"0.7"}),(0,t.jsx)(i.td,{children:"0"}),(0,t.jsx)(i.td,{children:"1.9"}),(0,t.jsx)(i.td,{children:"0.076"}),(0,t.jsx)(i.td,{children:"11"}),(0,t.jsx)(i.td,{children:"34"}),(0,t.jsx)(i.td,{children:"0.9978"}),(0,t.jsx)(i.td,{children:"3.51"}),(0,t.jsx)(i.td,{children:"0.56"}),(0,t.jsx)(i.td,{children:"9.4"}),(0,t.jsx)(i.td,{children:"5"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"7.8"}),(0,t.jsx)(i.td,{children:"0.88"}),(0,t.jsx)(i.td,{children:"0"}),(0,t.jsx)(i.td,{children:"2.6"}),(0,t.jsx)(i.td,{children:"0.098"}),(0,t.jsx)(i.td,{children:"25"}),(0,t.jsx)(i.td,{children:"67"}),(0,t.jsx)(i.td,{children:"0.9968"}),(0,t.jsx)(i.td,{children:"3.2"}),(0,t.jsx)(i.td,{children:"0.68"}),(0,t.jsx)(i.td,{children:"9.8"}),(0,t.jsx)(i.td,{children:"5"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"7.8"}),(0,t.jsx)(i.td,{children:"0.76"}),(0,t.jsx)(i.td,{children:"0.04"}),(0,t.jsx)(i.td,{children:"2.3"}),(0,t.jsx)(i.td,{children:"0.092"}),(0,t.jsx)(i.td,{children:"15"}),(0,t.jsx)(i.td,{children:"54"}),(0,t.jsx)(i.td,{children:"0.997"}),(0,t.jsx)(i.td,{children:"3.26"}),(0,t.jsx)(i.td,{children:"0.65"}),(0,t.jsx)(i.td,{children:"9.8"}),(0,t.jsx)(i.td,{children:"5"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"11.2"}),(0,t.jsx)(i.td,{children:"0.28"}),(0,t.jsx)(i.td,{children:"0.56"}),(0,t.jsx)(i.td,{children:"1.9"}),(0,t.jsx)(i.td,{children:"0.075"}),(0,t.jsx)(i.td,{children:"17"}),(0,t.jsx)(i.td,{children:"60"}),(0,t.jsx)(i.td,{children:"0.998"}),(0,t.jsx)(i.td,{children:"3.16"}),(0,t.jsx)(i.td,{children:"0.58"}),(0,t.jsx)(i.td,{children:"9.8"}),(0,t.jsx)(i.td,{children:"6"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"7.4"}),(0,t.jsx)(i.td,{children:"0.7"}),(0,t.jsx)(i.td,{children:"0"}),(0,t.jsx)(i.td,{children:"1.9"}),(0,t.jsx)(i.td,{children:"0.076"}),(0,t.jsx)(i.td,{children:"11"}),(0,t.jsx)(i.td,{children:"34"}),(0,t.jsx)(i.td,{children:"0.9978"}),(0,t.jsx)(i.td,{children:"3.51"}),(0,t.jsx)(i.td,{children:"0.56"}),(0,t.jsx)(i.td,{children:"9.4"}),(0,t.jsx)(i.td,{children:"5"})]})]})]}),"\n",(0,t.jsxs)(i.p,{children:["I ran into an issue trying to plot the quality distribution with ",(0,t.jsx)(i.code,{children:"plotly"})," - I noticed that the source CSV file used ",(0,t.jsx)(i.code,{children:";"})," instead of ",(0,t.jsx)(i.code,{children:","})," to separate cells. Now it works:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-py",children:"# quality distribution\nfig = px.histogram(df,x='quality')\nfig.show()\n"})}),"\n",(0,t.jsx)(i.p,{children:"The classes not balanced (e.g. there are much more normal wines than excellent or poor ones):"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"Wine Quality",src:n(283062).Z+"",width:"1507",height:"889"})}),"\n",(0,t.jsx)(i.p,{children:"The correlation matrix can show us what labels might have a good correlation with the perceived quality of the wine:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-py",children:'## correlation matrix\ncorr = df.corr()\nplt.subplots(figsize=(15,10))\nsns.heatmap(corr, xticklabels=corr.columns, yticklabels=corr.columns, annot=True, cmap=sns.diverging_palette(240, 170, center="light", as_cmap=True))\nplt.show()\n'})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"Wine Quality",src:n(171904).Z+"",width:"1500",height:"982"})}),"\n",(0,t.jsx)(i.h3,{id:"feature-importance",children:"Feature Importance"}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.strong,{children:"Correlation Matrix"})," already gives us an idea but only after fitting a well performing model can we decide what features are most important when it comes to classifying our wines. ",(0,t.jsx)(i.strong,{children:"SPOILER ALERT"}),": From the 5 classifier I will use below the ",(0,t.jsx)(i.strong,{children:"Random Forrest"})," and ",(0,t.jsx)(i.strong,{children:"XGBoost"})," will have the best performance."]}),"\n",(0,t.jsxs)(i.p,{children:["We can use the ",(0,t.jsx)(i.code,{children:"feature_importances_"})," function that is provided by the classifiers and extract a ranking of how important is each feature for the resulting classification, sort the results in a Panda Series using ",(0,t.jsx)(i.a,{href:"https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.nlargest.html",children:"nlargest"})," and ",(0,t.jsx)(i.a,{href:"https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.plot.html?highlight=plot#pandas.Series.plot",children:"plot"})," the results."]}),"\n",(0,t.jsx)(i.h4,{id:"red-wines",children:"Red Wines"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-py",children:"## RandomForestClassifier\nfeat_importances_forrest = pd.Series(forrest_model.feature_importances_, index=X_features.columns)\nfeat_importances_forrest.nlargest(11).plot(kind='pie', figsize=(10,10), title=\"Feature Importance :: RandomForestClassifier\")\nplt.show()\n\n## XGBClassifier\nfeat_importances_xbg = pd.Series(xgboost_model.feature_importances_, index=X_features.columns)\nfeat_importances_xbg.nlargest(11).plot(kind='pie', figsize=(10,10), title=\"Feature Importance :: XGBClassifier\")\nplt.show()\n"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"Wine Quality",src:n(30377).Z+"",width:"1527",height:"660"})}),"\n",(0,t.jsxs)(i.p,{children:["Both classifier models agree that the ",(0,t.jsx)(i.strong,{children:"Alcohol"})," content is the most important factor. Followed by the concentration of ",(0,t.jsx)(i.strong,{children:"Sulphates"}),". But after that their opinions seem to drift apart."]}),"\n",(0,t.jsxs)(i.p,{children:["Taking a look at the ",(0,t.jsx)(i.code,{children:"good"})," and ",(0,t.jsx)(i.code,{children:"bad"})," wines:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-py",children:'# get only good wines\ndf_good = df[df[\'good\']==1]\nprint(":: Wines with good Quality ::")\nprint("")\nprint(df_good.describe())\n# get only bad wines\ndf_bad = df[df[\'good\']==0]\nprint("")\nprint(":: Wines with bad Quality ::")\nprint("")\nprint(df_bad.describe())\n'})}),"\n",(0,t.jsx)(i.p,{children:"We can see that wines that are labelled as being good tend to have a higher alcohol and sulphate concentration:"}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"Wine Quality",src:n(476516).Z+"",width:"1575",height:"394"})}),"\n",(0,t.jsx)(i.h4,{id:"white-wines",children:"White Wines"}),"\n",(0,t.jsxs)(i.p,{children:["The same analysis for the white wine data shows also emphasizes the importance of the ",(0,t.jsx)(i.strong,{children:"Alcohol"})," content and a balance of sweetness and acidity. The sulfur factor is largely underrepresented:"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"Wine Quality",src:n(832843).Z+"",width:"1666",height:"660"})}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"Wine Quality",src:n(741343).Z+"",width:"1579",height:"395"})}),"\n",(0,t.jsx)(i.h2,{id:"data-pre-processing",children:"Data Pre-Processing"}),"\n",(0,t.jsx)(i.p,{children:"And now to the nitty, gritty of actually getting those results. To be able to work with our dataset we first have to do some housecleaning."}),"\n",(0,t.jsx)(i.h3,{id:"binary-classification",children:"Binary Classification"}),"\n",(0,t.jsxs)(i.p,{children:["As recommended by the ",(0,t.jsx)(i.a,{href:"https://www.kaggle.com/datasets/uciml/red-wine-quality-cortez-et-al-2009",children:"Author"})," we can make quality scale binary - everything with a quality below ",(0,t.jsx)(i.code,{children:"7"})," is just not worth your attention. So let's add another column ",(0,t.jsx)(i.code,{children:"good"})," and set it's value to ",(0,t.jsx)(i.code,{children:"1"})," if the quality is >= 7 and otherwise to ",(0,t.jsx)(i.code,{children:"0"}),":"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-py",children:"# make binary quality classification\ndf['good'] = [1 if x >= 7 else 0 for x in df['quality']]\n# separate feature and target variables\nX = df.drop(['quality', 'good'], axis = 1)\ny = df['good']\n# check distribution\nprint(df['good'].value_counts())\n# print first 5 rows\nprint(df.head())\n"})}),"\n",(0,t.jsxs)(i.p,{children:["The result is that we have ",(0,t.jsx)(i.code,{children:"217"})," out of ",(0,t.jsx)(i.code,{children:"1599"})," wines that are worth trying:"]}),"\n",(0,t.jsx)(i.p,{children:(0,t.jsx)(i.img,{alt:"Wine Quality",src:n(125362).Z+"",width:"1350",height:"151"})}),"\n",(0,t.jsx)(i.h3,{id:"data-normalization",children:"Data Normalization"}),"\n",(0,t.jsxs)(i.p,{children:["Because all the features in ",(0,t.jsx)(i.code,{children:"X"})," have different units / scales they cannot be compared directly but need to be normalized. We can use the ",(0,t.jsx)(i.a,{href:"https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.StandardScaler.html",children:"StandardScaler from SciKit Learn"})," to standardize those features by removing the mean and scaling to unit variance:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-py",children:"# Normalize feature variables\nX_features = X\nX = StandardScaler().fit_transform(X)\n"})}),"\n",(0,t.jsx)(i.h3,{id:"data-splitting",children:"Data Splitting"}),"\n",(0,t.jsxs)(i.p,{children:["To train our model we need a training and validation dataset to be able to establish performance metrics. And again it is ",(0,t.jsx)(i.code,{children:"sklearn"})," with ",(0,t.jsx)(i.a,{href:"https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.train_test_split.html",children:"train_test_split"})," that helps us to split the arrays or matrices into random train and test subsets. To get a random 25/75 split we can use:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-py",children:"# Splitting the data\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=.25, random_state=42)\n"})}),"\n",(0,t.jsx)(i.h2,{id:"fitting-a-model",children:"Fitting a Model"}),"\n",(0,t.jsxs)(i.p,{children:["Now we have to find a model that we can fit to our dataset. I found an article by ",(0,t.jsx)(i.a,{href:"https://towardsdatascience.com/predicting-wine-quality-with-several-classification-techniques-179038ea6434",children:"Terence Shin"})," that already explored several solutions to the classification problem."]}),"\n",(0,t.jsx)(i.h3,{id:"decision-tree",children:"Decision Tree"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.a,{href:"https://scikit-learn.org/stable/modules/tree.html#tree",children:"Decision Trees"})," are a non-parametric supervised learning method used for classification and regression. The goal is to create a model that predicts the value of a target variable by learning simple decision rules inferred from the data features. A tree can be seen as a piecewise constant approximation."]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"sklearn"})," provides a ",(0,t.jsx)(i.a,{href:"https://scikit-learn.org/stable/modules/generated/sklearn.tree.DecisionTreeClassifier.html",children:"A decision tree classifier."})," that we can apply to our problem"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-py",children:"## decision tree classifier\ntree_model = DecisionTreeClassifier(random_state=42)\n## use training dataset for fitting\ntree_model.fit(X_train, y_train)\n## run prediction based of the validation dataset\ny_pred1 = tree_model.predict(X_test)\n## get performance metrics\nprint(classification_report(y_test, y_pred1))\n"})}),"\n",(0,t.jsxs)(i.p,{children:["Running the classifier returns the following - the metrics I am looking out for here are ",(0,t.jsx)(i.code,{children:"precision"})," and ",(0,t.jsx)(i.code,{children:"recall"})," that give us a sense for the relation of true and false positives and negatives that were predicted during the validation run:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"precision"})," = TP / (TP + FP) |"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"recall"})," = TP / (TP + FN)"]}),"\n"]}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{}),(0,t.jsx)(i.th,{children:"precision"}),(0,t.jsx)(i.th,{children:"recall"}),(0,t.jsx)(i.th,{children:"f1-score"}),(0,t.jsx)(i.th,{children:"support"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"0"}),(0,t.jsx)(i.td,{children:"0.94"}),(0,t.jsx)(i.td,{children:"0.92"}),(0,t.jsx)(i.td,{children:"0.93"}),(0,t.jsx)(i.td,{children:"347"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"1"}),(0,t.jsx)(i.td,{children:"0.55"}),(0,t.jsx)(i.td,{children:"0.62"}),(0,t.jsx)(i.td,{children:"0.58"}),(0,t.jsx)(i.td,{children:"53"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"accuracy"}),(0,t.jsx)(i.td,{}),(0,t.jsx)(i.td,{}),(0,t.jsx)(i.td,{children:"0.88"}),(0,t.jsx)(i.td,{children:"400"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"macro avg"}),(0,t.jsx)(i.td,{children:"0.75"}),(0,t.jsx)(i.td,{children:"0.77"}),(0,t.jsx)(i.td,{children:"0.76"}),(0,t.jsx)(i.td,{children:"400"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"weighted avg"}),(0,t.jsx)(i.td,{children:"0.89"}),(0,t.jsx)(i.td,{children:"0.88"}),(0,t.jsx)(i.td,{children:"0.89"}),(0,t.jsx)(i.td,{children:"400"})]})]})]}),"\n",(0,t.jsxs)(i.p,{children:['We get a reasonably high precision for "bad wines" (',(0,t.jsx)(i.code,{children:"0"}),'). But it is basically hit or miss for "good wines" (',(0,t.jsx)(i.code,{children:"1"}),"). Since the dataset is not balanced and weighting in on the bad side we might see a model overfitting here:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Label 0"}),":","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.em,{children:"PRECISION"}),': Of all wines that were predicted as "not good", 94% were actually labelled with ',(0,t.jsx)(i.code,{children:"0"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.em,{children:"RECALL"}),": Of all wines that were truly labelled ",(0,t.jsx)(i.code,{children:"0"})," we predicted 92% correctly."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Label 1"}),":","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.em,{children:"PRECISION"}),': Of all wines that were predicted as "good", 55% were actually labelled with ',(0,t.jsx)(i.code,{children:"1"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.em,{children:"RECALL"}),": Of all wines that were truly labelled ",(0,t.jsx)(i.code,{children:"1"})," we predicted 62% correctly."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"random-forest",children:"Random Forest"}),"\n",(0,t.jsxs)(i.p,{children:["Next, another ",(0,t.jsx)(i.code,{children:"sklearn"})," classifier - the ",(0,t.jsx)(i.a,{href:"https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.RandomForestClassifier.html",children:"RandomForestClassifier"}),". A random forest is a meta estimator that fits a number of decision tree classifiers on various sub-samples of the dataset and uses averaging to improve the predictive accuracy and control over-fitting. The sub-sample size is controlled with the ",(0,t.jsx)(i.code,{children:"max_samples"})," parameter if ",(0,t.jsx)(i.code,{children:"bootstrap=True"})," (default), otherwise the whole dataset is used to build each tree:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-py",children:"## random forrest classifier\nforrest_model = RandomForestClassifier(random_state=42)\n## use training dataset for fitting\nforrest_model.fit(X_train, y_train)\n## run prediction based of the validation dataset\ny_pred2 = forrest_model.predict(X_test)\n## get performance metrics\nprint(classification_report(y_test, y_pred2))\n"})}),"\n",(0,t.jsx)(i.p,{children:"Running the classifier returns the following:"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{}),(0,t.jsx)(i.th,{children:"precision"}),(0,t.jsx)(i.th,{children:"recall"}),(0,t.jsx)(i.th,{children:"f1-score"}),(0,t.jsx)(i.th,{children:"support"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"0"}),(0,t.jsx)(i.td,{children:"0.93"}),(0,t.jsx)(i.td,{children:"0.97"}),(0,t.jsx)(i.td,{children:"0.95"}),(0,t.jsx)(i.td,{children:"347"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"1"}),(0,t.jsx)(i.td,{children:"0.75"}),(0,t.jsx)(i.td,{children:"0.51"}),(0,t.jsx)(i.td,{children:"0.61"}),(0,t.jsx)(i.td,{children:"53"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"accuracy"}),(0,t.jsx)(i.td,{}),(0,t.jsx)(i.td,{}),(0,t.jsx)(i.td,{children:"0.91"}),(0,t.jsx)(i.td,{children:"400"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"macro avg"}),(0,t.jsx)(i.td,{children:"0.84"}),(0,t.jsx)(i.td,{children:"0.74"}),(0,t.jsx)(i.td,{children:"0.78"}),(0,t.jsx)(i.td,{children:"400"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"weighted avg"}),(0,t.jsx)(i.td,{children:"0.90"}),(0,t.jsx)(i.td,{children:"0.91"}),(0,t.jsx)(i.td,{children:"0.91"}),(0,t.jsx)(i.td,{children:"400"})]})]})]}),"\n",(0,t.jsxs)(i.p,{children:['Again, we get a reasonably high precision for "bad wines" (',(0,t.jsx)(i.code,{children:"0"}),"). And using several random decision trees and averaging the results helped us tackle the overfitting - at least a bit (",(0,t.jsx)(i.code,{children:"recall"})," actually got worse):"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Label 0"}),":","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.em,{children:"PRECISION"}),': Of all wines that were predicted as "not good", 93% were actually labelled with ',(0,t.jsx)(i.code,{children:"0"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.em,{children:"RECALL"}),": Of all wines that were truly labelled ",(0,t.jsx)(i.code,{children:"0"})," we predicted 97% correctly."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Label 1"}),":","\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.em,{children:"PRECISION"}),': Of all wines that were predicted as "good", 75% were actually labelled with ',(0,t.jsx)(i.code,{children:"1"}),"."]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.em,{children:"RECALL"}),": Of all wines that were truly labelled ",(0,t.jsx)(i.code,{children:"1"})," we predicted 51% correctly."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"adaboost",children:"AdaBoost"}),"\n",(0,t.jsxs)(i.p,{children:["An ",(0,t.jsx)(i.a,{href:"https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.AdaBoostClassifier.html",children:"AdaBoost classifier"})," is a meta-estimator that begins by fitting a classifier on the original dataset and then fits additional copies of the classifier on the same dataset but where the weights of incorrectly classified instances are adjusted such that subsequent classifiers focus more on difficult cases:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-py",children:"## adaboost classifier\nadaboost_model = AdaBoostClassifier(random_state=42)\n## use training dataset for fitting\nadaboost_model.fit(X_train, y_train)\n## run prediction based of the validation dataset\ny_pred3 = adaboost_model.predict(X_test)\n## get performance metrics\nprint(classification_report(y_test, y_pred3))\n"})}),"\n",(0,t.jsx)(i.p,{children:"Running the classifier returns the following:"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{}),(0,t.jsx)(i.th,{children:"precision"}),(0,t.jsx)(i.th,{children:"recall"}),(0,t.jsx)(i.th,{children:"f1-score"}),(0,t.jsx)(i.th,{children:"support"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"0"}),(0,t.jsx)(i.td,{children:"0.90"}),(0,t.jsx)(i.td,{children:"0.95"}),(0,t.jsx)(i.td,{children:"0.93"}),(0,t.jsx)(i.td,{children:"347"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"1"}),(0,t.jsx)(i.td,{children:"0.50"}),(0,t.jsx)(i.td,{children:"0.32"}),(0,t.jsx)(i.td,{children:"0.39"}),(0,t.jsx)(i.td,{children:"53"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"accuracy"}),(0,t.jsx)(i.td,{}),(0,t.jsx)(i.td,{}),(0,t.jsx)(i.td,{children:"0.87"}),(0,t.jsx)(i.td,{children:"400"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"macro avg"}),(0,t.jsx)(i.td,{children:"0.70"}),(0,t.jsx)(i.td,{children:"0.64"}),(0,t.jsx)(i.td,{children:"0.66"}),(0,t.jsx)(i.td,{children:"400"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"weighted avg"}),(0,t.jsx)(i.td,{children:"0.85"}),(0,t.jsx)(i.td,{children:"0.87"}),(0,t.jsx)(i.td,{children:"0.85"}),(0,t.jsx)(i.td,{children:"400"})]})]})]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.em,{children:"Nope"})," ..."]}),"\n",(0,t.jsx)(i.h3,{id:"gradient-boosting",children:"Gradient Boosting"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.a,{href:"https://scikit-learn.org/stable/modules/generated/sklearn.ensemble.GradientBoostingClassifier.html",children:"Gradient Boosting"})," classification algorithm builds an additive model in a forward stage-wise fashion. It allows for the optimization of arbitrary differentiable loss functions. In each stage ",(0,t.jsx)(i.code,{children:"n_classes_ regression"})," trees are fit on the negative gradient of the loss function. Binary classification is a special case where only a single regression tree is induced:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-py",children:"## gradient boost classifier\ngradient_model = GradientBoostingClassifier(random_state=42)\n## use training dataset for fitting\ngradient_model.fit(X_train, y_train)\n## run prediction based of the validation dataset\ny_pred4 = gradient_model.predict(X_test)\n## get performance metrics\nprint(classification_report(y_test, y_pred4))\n"})}),"\n",(0,t.jsx)(i.p,{children:"Running the classifier returns the following:"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{}),(0,t.jsx)(i.th,{children:"precision"}),(0,t.jsx)(i.th,{children:"recall"}),(0,t.jsx)(i.th,{children:"f1-score"}),(0,t.jsx)(i.th,{children:"support"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"0"}),(0,t.jsx)(i.td,{children:"0.92"}),(0,t.jsx)(i.td,{children:"0.94"}),(0,t.jsx)(i.td,{children:"0.93"}),(0,t.jsx)(i.td,{children:"347"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"1"}),(0,t.jsx)(i.td,{children:"0.53"}),(0,t.jsx)(i.td,{children:"0.43"}),(0,t.jsx)(i.td,{children:"0.48"}),(0,t.jsx)(i.td,{children:"53"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"accuracy"}),(0,t.jsx)(i.td,{}),(0,t.jsx)(i.td,{}),(0,t.jsx)(i.td,{children:"0.88"}),(0,t.jsx)(i.td,{children:"400"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"macro avg"}),(0,t.jsx)(i.td,{children:"0.73"}),(0,t.jsx)(i.td,{children:"0.69"}),(0,t.jsx)(i.td,{children:"0.70"}),(0,t.jsx)(i.td,{children:"400"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"weighted avg"}),(0,t.jsx)(i.td,{children:"0.87"}),(0,t.jsx)(i.td,{children:"0.88"}),(0,t.jsx)(i.td,{children:"0.87"}),(0,t.jsx)(i.td,{children:"400"})]})]})]}),"\n",(0,t.jsx)(i.p,{children:"Better but not good, yet ..."}),"\n",(0,t.jsx)(i.h3,{id:"xgboost",children:"XGBoost"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.a,{href:"https://xgboost.readthedocs.io/en/stable/index.html",children:"XGBoost"})," is an optimized distributed gradient boosting library designed to be highly efficient, flexible and portable. It implements machine learning algorithms under the Gradient Boosting framework. XGBoost provides a parallel tree boosting (also known as GBDT, GBM):"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-py",children:"import xgboost as xgb\nxgboost_model = xgb.XGBClassifier(random_state=1)\nxgboost_model.fit(X_train, y_train)\ny_pred5 = xgboost_model.predict(X_test)print(classification_report(y_test, y_pred5))\n"})}),"\n",(0,t.jsx)(i.p,{children:"Running the classifier returns the following:"}),"\n",(0,t.jsxs)(i.table,{children:[(0,t.jsx)(i.thead,{children:(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.th,{}),(0,t.jsx)(i.th,{children:"precision"}),(0,t.jsx)(i.th,{children:"recall"}),(0,t.jsx)(i.th,{children:"f1-score"}),(0,t.jsx)(i.th,{children:"support"})]})}),(0,t.jsxs)(i.tbody,{children:[(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"0"}),(0,t.jsx)(i.td,{children:"0.94"}),(0,t.jsx)(i.td,{children:"0.96"}),(0,t.jsx)(i.td,{children:"0.95"}),(0,t.jsx)(i.td,{children:"347"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"1"}),(0,t.jsx)(i.td,{children:"0.70"}),(0,t.jsx)(i.td,{children:"0.62"}),(0,t.jsx)(i.td,{children:"0.66"}),(0,t.jsx)(i.td,{children:"53"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"accuracy"}),(0,t.jsx)(i.td,{}),(0,t.jsx)(i.td,{}),(0,t.jsx)(i.td,{children:"0.92"}),(0,t.jsx)(i.td,{children:"400"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"macro avg"}),(0,t.jsx)(i.td,{children:"0.82"}),(0,t.jsx)(i.td,{children:"0.79"}),(0,t.jsx)(i.td,{children:"0.81"}),(0,t.jsx)(i.td,{children:"400"})]}),(0,t.jsxs)(i.tr,{children:[(0,t.jsx)(i.td,{children:"weighted avg"}),(0,t.jsx)(i.td,{children:"0.91"}),(0,t.jsx)(i.td,{children:"0.92"}),(0,t.jsx)(i.td,{children:"0.91"}),(0,t.jsx)(i.td,{children:"400"})]})]})]}),"\n",(0,t.jsxs)(i.p,{children:["This is the best of the boosting classifier so far. The ",(0,t.jsx)(i.code,{children:"precision"})," for positives is 5% lower but the ",(0,t.jsx)(i.code,{children:"recall"})," is ",(0,t.jsx)(i.code,{children:"11%"})," better than the ",(0,t.jsx)(i.a,{href:"#random-forest",children:"Random Forest"})," results. So this might be the best performing classifier of the lot."]})]})}function o(e={}){const{wrapper:i}={...(0,s.ah)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},603905:(e,i,n)=>{n.d(i,{ah:()=>c});var t=n(667294);function s(e,i,n){return i in e?Object.defineProperty(e,i,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[i]=n,e}function r(e,i){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);i&&(t=t.filter((function(i){return Object.getOwnPropertyDescriptor(e,i).enumerable}))),n.push.apply(n,t)}return n}function d(e){for(var i=1;i<arguments.length;i++){var n=null!=arguments[i]?arguments[i]:{};i%2?r(Object(n),!0).forEach((function(i){s(e,i,n[i])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(i){Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(n,i))}))}return e}function a(e,i){if(null==e)return{};var n,t,s=function(e,i){if(null==e)return{};var n,t,s={},r=Object.keys(e);for(t=0;t<r.length;t++)n=r[t],i.indexOf(n)>=0||(s[n]=e[n]);return s}(e,i);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)n=r[t],i.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=t.createContext({}),c=function(e){var i=t.useContext(l),n=i;return e&&(n="function"==typeof e?e(i):d(d({},i),e)),n},h={inlineCode:"code",wrapper:function(e){var i=e.children;return t.createElement(t.Fragment,{},i)}},o=t.forwardRef((function(e,i){var n=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,o=a(e,["components","mdxType","originalType","parentName"]),x=c(n),j=s,p=x["".concat(l,".").concat(j)]||x[j]||h[j]||r;return n?t.createElement(p,d(d({ref:i},o),{},{components:n})):t.createElement(p,d({ref:i},o))}));o.displayName="MDXCreateElement"},283062:(e,i,n)=>{n.d(i,{Z:()=>t});const t=n.p+"assets/images/Win_Quality_Dataset_01-c32ea1909fe02b36c4a52e94f3700d4d.png"},171904:(e,i,n)=>{n.d(i,{Z:()=>t});const t=n.p+"assets/images/Win_Quality_Dataset_02-a7fbc3ac1567084cda2fcd7c6d9f05e0.png"},125362:(e,i,n)=>{n.d(i,{Z:()=>t});const t=n.p+"assets/images/Win_Quality_Dataset_03-d2dd77b4306939e2784fb17b4c8be1a1.png"},30377:(e,i,n)=>{n.d(i,{Z:()=>t});const t=n.p+"assets/images/Win_Quality_Dataset_04-a010dc8acd0ed48b0f57f7f19814cd81.png"},476516:(e,i,n)=>{n.d(i,{Z:()=>t});const t=n.p+"assets/images/Win_Quality_Dataset_05-376ae6f66103016eb05e2425fd7c151b.png"},832843:(e,i,n)=>{n.d(i,{Z:()=>t});const t=n.p+"assets/images/Win_Quality_Dataset_06-4fb3107e8f1628feed516f9e427d2fc1.png"},741343:(e,i,n)=>{n.d(i,{Z:()=>t});const t=n.p+"assets/images/Win_Quality_Dataset_07-1223b78884cc30c0c831a1618341beb0.png"},685287:(e,i,n)=>{n.d(i,{Z:()=>t});const t=n.p+"assets/images/photo-kt443t6d_64hdh43hfh6dgjdfhg4_d-1a51e7538c86faba8096715524fe16fa.jpg"}}]);