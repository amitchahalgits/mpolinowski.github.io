"use strict";(self.webpackChunkmikes_dev_notebook=self.webpackChunkmikes_dev_notebook||[]).push([[4483],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var o=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),c=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(n),h=a,m=u["".concat(l,".").concat(h)]||u[h]||d[h]||r;return n?o.createElement(m,i(i({ref:t},p),{},{components:n})):o.createElement(m,i({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},51866:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var o=n(87462),a=(n(67294),n(3905));const r={sidebar_position:4010,slug:"2022-11-11",title:"Hashicorp Nomad to run periodic backups",authors:"mpolinowski",tags:["Nomad","LINUX"],description:"Dockerized version of Borg Backup Server with Docker and Nomad"},i=void 0,s={unversionedId:"DevOps/Hashicorp/2022-11-11-hashicorp-nomad-for-borg-backups/index",id:"DevOps/Hashicorp/2022-11-11-hashicorp-nomad-for-borg-backups/index",title:"Hashicorp Nomad to run periodic backups",description:"Dockerized version of Borg Backup Server with Docker and Nomad",source:"@site/docs/DevOps/Hashicorp/2022-11-11-hashicorp-nomad-for-borg-backups/index.md",sourceDirName:"DevOps/Hashicorp/2022-11-11-hashicorp-nomad-for-borg-backups",slug:"/DevOps/Hashicorp/2022-11-11-hashicorp-nomad-for-borg-backups/2022-11-11",permalink:"/docs/DevOps/Hashicorp/2022-11-11-hashicorp-nomad-for-borg-backups/2022-11-11",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/DevOps/Hashicorp/2022-11-11-hashicorp-nomad-for-borg-backups/index.md",tags:[{label:"Nomad",permalink:"/docs/tags/nomad"},{label:"LINUX",permalink:"/docs/tags/linux"}],version:"current",sidebarPosition:4010,frontMatter:{sidebar_position:4010,slug:"2022-11-11",title:"Hashicorp Nomad to run periodic backups",authors:"mpolinowski",tags:["Nomad","LINUX"],description:"Dockerized version of Borg Backup Server with Docker and Nomad"},sidebar:"tutorialSidebar",previous:{title:"Hashicorp Nomad to Renew your TLS Certificates",permalink:"/docs/DevOps/Hashicorp/2022-11-12-hashicorp-nomad-certbot-renewal/2022-11-12"},next:{title:"Hashicorp Nomad to set up an OSTicket Helpdesk - Part II",permalink:"/docs/DevOps/Hashicorp/2022-10-25-hashicorp-nomad-for-osticket-part-ii/2022-10-25"}},l={},c=[{value:"From Docker to Nomad",id:"from-docker-to-nomad",level:2},{value:"Preparing the Nomad Client",id:"preparing-the-nomad-client",level:2},{value:"Periodic Runs",id:"periodic-runs",level:2},{value:"Batch",id:"batch",level:3},{value:"System Batch",id:"system-batch",level:3},{value:"Complete Nomad Job File",id:"complete-nomad-job-file",level:3},{value:"Running the Job",id:"running-the-job",level:2},{value:"Restore a Backup",id:"restore-a-backup",level:2}],p={toc:c};function d(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,o.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Shen Zhen, China",src:n(40599).Z,width:"2230",height:"839"})),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#from-docker-to-nomad"},"From Docker to Nomad")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#preparing-the-nomad-client"},"Preparing the Nomad Client")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#periodic-runs"},"Periodic Runs"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#batch"},"Batch")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#system-batch"},"System Batch")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#complete-nomad-job-file"},"Complete Nomad Job File")))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#running-the-job"},"Running the Job")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#restore-a-backup"},"Restore a Backup"))),(0,a.kt)("p",null,"Preparation -> see ",(0,a.kt)("a",{parentName:"p",href:"/docs/DevOps/Linux/2022-11-09--docker-borg-backupserver/2022-11-09"},"Resistance is futile - Borg with Docker"),"."),(0,a.kt)("h2",{id:"from-docker-to-nomad"},"From Docker to Nomad"),(0,a.kt)("p",null,"I want to use Nomad to execute the following Docker command for me periodically to create daily backups of selected files:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"docker run \\\n  --rm \\\n  -e BORG_REPO=/opt/borg \\\n  -e BORG_PASSPHRASE=mypassword \\\n  -e BACKUP_DIRS=/data \\\n  -e ARCHIVE=osticket-db-$(date +%Y-%m-%d) \\\n  -e COMPRESSION=lz4 \\\n  -e PRUNE=1 \\\n  -e KEEP_DAILY=1 \\\n  -e KEEP_WEEKLY=0 \\\n  -e KEEP_MONTHLY=0 \\\n  -v /opt/borg/config:/root \\\n  -v /opt/borg/repo:/opt/borg \\\n  -v /opt/temp1:/data/temp1:ro \\\n  -v /opt/temp2:/data/temp2:ro \\\n  --security-opt label:disable \\\n  --name borg-backup \\\n  pschiffe/borg\n")),(0,a.kt)("p",null,"The server I deploy this container to must have the directory ",(0,a.kt)("inlineCode",{parentName:"p"},"/opt/borg/config")," that contains the Borg configuration (this will be auto-generated on the first run and then recycled). And the dir ",(0,a.kt)("inlineCode",{parentName:"p"},"/opt/borg/repo")," (this is most likely going to change to a mounted network storage later on) that will contain the password protected backup."),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"BACKUP_DIRS")," variable is set to ",(0,a.kt)("inlineCode",{parentName:"p"},"/data")," - this is the directory inside the Docker container that will be backed-up. Every directory that I want to be backed up from my host system needs to be mounted in that location - this can be several locations from all over the host system, e.g. ",(0,a.kt)("inlineCode",{parentName:"p"}," -v /opt/temp1:/data/temp1:ro \\"),". These directories will be mounted as ",(0,a.kt)("em",{parentName:"p"},"read-only")," to make sure that the source data is not going to be altered in any way."),(0,a.kt)("p",null,"This backup is a backup on a backup - the server itself is constantly mirrored in itself. This service is only meant to provide a quick way to revert changes made to a database without having to role back the entire server. So I activated ",(0,a.kt)("strong",{parentName:"p"},"Pruning")," and I only want to keep 1 backup - but I am not sure yet if setting ",(0,a.kt)("em",{parentName:"p"},"monthly")," and ",(0,a.kt)("em",{parentName:"p"},"weekly")," to 0 actually works. This is just a test-run."),(0,a.kt)("h2",{id:"preparing-the-nomad-client"},"Preparing the Nomad Client"),(0,a.kt)("p",null,"The Client is a server running OSTicket and MariaDB + a NGINX Ingress. Since all of them are provisioned using Nomad I already have the volume mount for the directory I want to backup - the MariaDB data dir. All I need to add now is the Borg configuration and repo path to my Nomad Client:"),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"/etc/nomad.d/client.hcl")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'client {\n  enabled = true\n  servers = ["myserver:port"]\n\n  host_volume "letsencrypt" {\n    path = "/etc/letsencrypt"\n    read_only = false\n  }\n\n  host_volume "osticket_db" {\n    path = "/opt/osticket/db"\n    read_only = false\n  }\n\n  host_volume "borg_config" {\n    path = "/opt/borg/config"\n    read_only = false\n  }\n\n  host_volume "borg_repo" {\n    path = "/opt/borg/repo"\n    read_only = false\n  }\n}\n\n# Docker Configuration\nplugin "docker" {\n\n  volumes {\n    enabled      = true\n    selinuxlabel = "z"\n  }\n\n  allow_privileged = false\n  allow_caps       = ["chown", "net_raw"]\n\n}\n')),(0,a.kt)("h2",{id:"periodic-runs"},"Periodic Runs"),(0,a.kt)("p",null,"I am going to use the ",(0,a.kt)("inlineCode",{parentName:"p"},"periodic"),' stanza to run the Nomad job at fixed times, dates, or intervals. The easiest way to think about the periodic scheduler is "Nomad cron" or "distributed cron":'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'job "docs" {\n  periodic {\n    cron = "*/15 * * * * *"\n    time_zone = "Europe/Berlin"\n    prohibit_overlap = true\n    enabled = true\n  }\n}\n')),(0,a.kt)("p",null,"To get started I will just use ",(0,a.kt)("inlineCode",{parentName:"p"},'cron = "@daily"')," to execute the job once a day. But we first have to specify the ",(0,a.kt)("strong",{parentName:"p"},"Scheduler"),". Nomad has four scheduler types that can be used when creating your job: ",(0,a.kt)("inlineCode",{parentName:"p"},"service"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"batch"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"system")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"sysbatch"),":"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Error during plan: Unexpected response code: 500 (1 error occurred:"),(0,a.kt)("pre",{parentName:"blockquote"},(0,a.kt)("code",{parentName:"pre"},'   * Periodic can only be used with "batch" or "sysbatch" scheduler)\n'))),(0,a.kt)("h3",{id:"batch"},"Batch"),(0,a.kt)("p",null,"Batch jobs are much less sensitive to short term performance fluctuations and are short lived, finishing in a few minutes to a few days. Although the batch scheduler is very similar to the service scheduler, it makes certain optimizations for the batch workload."),(0,a.kt)("p",null,"Batch jobs are intended to run until they exit successfully. Batch tasks that exit with an error are handled according to the job's restart and ",(0,a.kt)("a",{parentName:"p",href:"https://developer.hashicorp.com/nomad/docs/job-specification/reschedule"},"reschedule stanzas"),"."),(0,a.kt)("h3",{id:"system-batch"},"System Batch"),(0,a.kt)("p",null,"The sysbatch scheduler is used to register jobs that should be run to completion on all clients that meet the job's constraints. The sysbatch scheduler will schedule jobs similarly to the system scheduler, but like a batch job once a task exits successfully it is not restarted on that client."),(0,a.kt)("p",null,'This scheduler type is useful for issuing "one off" commands to be run on every node in the cluster. Sysbatch jobs can also be created as periodic and parameterized jobs. Since these tasks are managed by Nomad, they can take advantage of job updating, service discovery, monitoring, and more.'),(0,a.kt)("p",null,"The sysbatch scheduler will preempt lower priority tasks running on a node if there is not enough capacity to place the job. See preemption details on how tasks that get preempted are chosen."),(0,a.kt)("p",null,"Sysbatch jobs are intended to run until successful completion, explicitly stopped by an operator, or evicted through preemption. Sysbatch tasks that exit with an error are handled according to the job's restart stanza."),(0,a.kt)("p",null,"So since I will only be running the service on one node and I do not want to the service to be re-scheduled in case that it fails:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'job "backup-osticket" {\n  \n  periodic {\n    cron = "@daily"\n  }\n\n  type = "batch"\n\n  reschedule {\n      attempts  = 0\n      unlimited = false\n    }\n')),(0,a.kt)("h3",{id:"complete-nomad-job-file"},"Complete Nomad Job File"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'job "osticket-backup" {\n    periodic {\n      cron = "@daily"\n    }\n    type = "batch"\n    reschedule {\n      attempts  = 0\n      unlimited = false\n    }\n    datacenters = ["MyDatacenter"]\n    group "osticket-backup" {\n\n        volume "osticket_db" {\n            type      = "host"\n            read_only = false\n            source    = "osticket_db"\n        }\n\n        volume "borg_config" {\n            type      = "host"\n            read_only = false\n            source    = "borg_config"\n        }\n\n        volume "borg_repo" {\n            type      = "host"\n            read_only = false\n            source    = "borg_repo"\n        }\n\n        task "osticket-backup-db" {\n            driver = "docker"\n\n            config {\n                image = "pschiffe/borg"\n                force_pull = false\n            }\n\n            volume_mount {\n                volume      = "osticket_db"\n                destination = "/data" #<-- in the container\n                read_only   = false\n            }\n\n            volume_mount {\n                volume      = "borg_config"\n                destination = "/root" #<-- in the container\n                read_only   = false\n            }\n\n            volume_mount {\n                volume      = "borg_repo"\n                destination = "/opt/borg" #<-- in the container\n                read_only   = false\n            }\n\n            env {\n                BORG_REPO="/opt/borg"\n                BORG_PASSPHRASE="mypassword"\n                BACKUP_DIRS="/data"\n                ARCHIVE="osticket-db"\n                COMPRESSION="lz4"\n                PRUNE=1\n                KEEP_DAILY=1\n                KEEP_WEEKLY=0\n                KEEP_MONTHLY=0\n            }\n        }\n    }\n}\n')),(0,a.kt)("h2",{id:"running-the-job"},"Running the Job"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'nomad plan osticket_backup.tf\n\n+ Job: "backup-osticket"\n+ Task Group: "backup-osticket" (1 create)\n  + Task: "backup-osticket-db" (forces create)\n\nScheduler dry-run:\n- All tasks successfully allocated.\n- If submitted now, next periodic launch would be at 2022-11-13T00:00:00Z (12h29m2s from now).\n\nJob Modify Index: 0\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"nomad job run -check-index 0 osticket_backup.tf\n\nJob registration successful\nApproximate next launch time: 2022-11-13T00:00:00Z (12h27m45s from now)\n")),(0,a.kt)("p",null,"So the job was registered and is supposed to run at midnight."),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"ERROR"),": ",(0,a.kt)("inlineCode",{parentName:"p"},'Exit Code: 2, Exit Message: "Docker container exited with non-zero exit code: 2"'))),(0,a.kt)("p",null,"I kept getting error messages and container crashes. I have seen this before with Nomad - when setting ",(0,a.kt)("inlineCode",{parentName:"p"},"read_only=true")," for a volume mount (even though the service should not be able to write into this mount). The error dissapears when I give the write permission:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'volume_mount {\n    volume      = "osticket_db"\n    destination = "/data" #<-- in the container\n    read_only   = false\n}\n')),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Hashicorp Nomad to run periodic backups",src:n(78443).Z,width:"1322",height:"763"})),(0,a.kt)("p",null,"Now the job is running."),(0,a.kt)("h2",{id:"restore-a-backup"},"Restore a Backup"),(0,a.kt)("p",null,"A ",(0,a.kt)("a",{parentName:"p",href:"/docs/DevOps/Linux/2022-11-09--docker-borg-backupserver/2022-11-09#restore"},"restore can be run manually")," and then copied to the data directory restoring the old database:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"docker run \\\n  --rm \\\n  -e BORG_REPO=/opt/borg \\\n  -e ARCHIVE=osticket-db \\\n  -e BORG_PASSPHRASE=mypassword \\\n  -e EXTRACT_TO=/borg/output \\\n  -v /opt/borg/config:/root \\\n  -v /opt/borg/repo:/opt/borg \\\n  -v /opt/borg/output:/borg/output/data \\\n  --security-opt label:disable \\\n  --name borg-backup \\\n  pschiffe/borg\n")))}d.isMDXComponent=!0},78443:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/Hashicorp_Nomad_to_run_periodic_backups_01-a05642a5d2d08ce711f8a3ee4ffe03b3.png"},40599:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/photo-kt443t6d_64hdh43hfh6dgjdfhg4_d-6c1edb088dfea3a7d39f8eebb8e9dc23.jpg"}}]);