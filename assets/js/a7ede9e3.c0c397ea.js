"use strict";(self.webpackChunkmikes_dev_notebook=self.webpackChunkmikes_dev_notebook||[]).push([[44478],{378031:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>a,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var s=t(474848),i=t(28453);const r={sidebar_position:6090,slug:"2022-07-21",title:"Rust - MQTT Hello World",authors:"mpolinowski",tags:["IoT"],image:"https://mpolinowski.github.io/img/search/mqtt.png",description:"Rust is a multi-paradigm programming language designed for performance and safety, especially safe concurrency. Rust is syntactically similar to C++, but can guarantee memory safety by using a borrow checker to validate references."},o=void 0,l={id:"Automation_and_Robotics/MQTT/2022-07-21-rust-hello-world/index",title:"Rust - MQTT Hello World",description:"Rust is a multi-paradigm programming language designed for performance and safety, especially safe concurrency. Rust is syntactically similar to C++, but can guarantee memory safety by using a borrow checker to validate references.",source:"@site/docs/Automation_and_Robotics/MQTT/2022-07-21-rust-hello-world/index.md",sourceDirName:"Automation_and_Robotics/MQTT/2022-07-21-rust-hello-world",slug:"/Automation_and_Robotics/MQTT/2022-07-21-rust-hello-world/2022-07-21",permalink:"/docs/Automation_and_Robotics/MQTT/2022-07-21-rust-hello-world/2022-07-21",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Automation_and_Robotics/MQTT/2022-07-21-rust-hello-world/index.md",tags:[{label:"IoT",permalink:"/docs/tags/io-t"}],version:"current",sidebarPosition:6090,frontMatter:{sidebar_position:6090,slug:"2022-07-21",title:"Rust - MQTT Hello World",authors:"mpolinowski",tags:["IoT"],image:"https://mpolinowski.github.io/img/search/mqtt.png",description:"Rust is a multi-paradigm programming language designed for performance and safety, especially safe concurrency. Rust is syntactically similar to C++, but can guarantee memory safety by using a borrow checker to validate references."},sidebar:"tutorialSidebar",previous:{title:"Go - MQTT Hello World",permalink:"/docs/Automation_and_Robotics/MQTT/2022-07-22-go-hello-world/2022-07-22"},next:{title:"INSTAR MQTTv5 with Python - Client Connection",permalink:"/docs/Automation_and_Robotics/MQTT/2022-06-23-instar-mqtt-python-part-I/2022-06-23"}},a={},c=[{value:"Rust Up",id:"rust-up",level:2},{value:"Hello World",id:"hello-world",level:2},{value:"Rusty MQTT",id:"rusty-mqtt",level:2},{value:"Initialisation the Project",id:"initialisation-the-project",level:3},{value:"MQTT Subscription",id:"mqtt-subscription",level:3},{value:"MQTT Publication",id:"mqtt-publication",level:3},{value:"Compile Binary Files",id:"compile-binary-files",level:3}];function d(n){const e={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"Guangzhou, China",src:t(231413).A+"",width:"2385",height:"962"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#rust-up",children:"Rust Up"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#hello-world",children:"Hello World"})}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.a,{href:"#rusty-mqtt",children:"Rusty MQTT"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#initialisation-the-project",children:"Initialisation the Project"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#mqtt-subscription",children:"MQTT Subscription"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#mqtt-publication",children:"MQTT Publication"})}),"\n",(0,s.jsx)(e.li,{children:(0,s.jsx)(e.a,{href:"#compile-binary-files",children:"Compile Binary Files"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Rust is a multi-paradigm programming language designed for performance and safety, especially safe concurrency. Rust is syntactically similar to C++, but can guarantee memory safety by using a borrow checker to validate references. Rust achieves memory safety without garbage collection, and reference counting is optional."}),"\n",(0,s.jsx)(e.h2,{id:"rust-up",children:"Rust Up"}),"\n",(0,s.jsxs)(e.p,{children:["Install Rust using ",(0,s.jsx)(e.a,{href:"https://www.rust-lang.org/tools/install",children:"rustup"}),". To download Rustup and install Rust, run the following in your terminal, then follow the on-screen instructions:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n"})}),"\n",(0,s.jsxs)(e.p,{children:["In the Rust development environment, all tools are installed to the ~/.cargo/bin directory, and this is where you will find the Rust toolchain, including ",(0,s.jsx)(e.code,{children:"rustc"}),", ",(0,s.jsx)(e.code,{children:"cargo"}),", and ",(0,s.jsx)(e.code,{children:"rustup"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"rustc --version\nrustc 1.63.0 (4b91a6ea7 2022-08-08)\n"})}),"\n",(0,s.jsx)(e.p,{children:"You can update your installation by running:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"rustup update\nstable-x86_64-unknown-linux-gnu unchanged - rustc 1.63.0 (4b91a6ea7 2022-08-08)\n"})}),"\n",(0,s.jsx)(e.p,{children:"If at any point you would like to uninstall Rust, you can run:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"rustup self uninstall\n"})}),"\n",(0,s.jsx)(e.h2,{id:"hello-world",children:"Hello World"}),"\n",(0,s.jsx)(e.p,{children:"This is the source code of the traditional Hello World program."}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.em,{children:"hello.rs"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'// This is the main function\nfn main() {\n    // Statements here are executed when the compiled binary is called\n\n    // Print text to the console\n    println!("Hello World!");\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:["A binary can be generated using the Rust compiler ",(0,s.jsx)(e.code,{children:"rustc"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"rustc hello.rs\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"rustc"})," will produce a hello binary that can be executed."]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"./hello\nHello World!\n"})}),"\n",(0,s.jsx)(e.h2,{id:"rusty-mqtt",children:"Rusty MQTT"}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"FAIL"}),": I don't know how to add a user login and the connection to my broker fails. The ",(0,s.jsx)(e.a,{href:"https://docs.rs/paho-mqtt/latest/paho_mqtt/create_options/struct.CreateOptionsBuilder.html#method.user_data",children:"official documentation"})," does not mention username/password \xaf\\",(0,s.jsx)(e.em,{children:"(\u30c4)"}),"/\xaf  I will try ",(0,s.jsx)(e.a,{href:"/docs/Automation_and_Robotics/MQTT/2022-07-22-go-hello-world/2022-07-22",children:"using Go instead"}),"."]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:["Now I want to use the ",(0,s.jsx)(e.a,{href:"https://github.com/eclipse/paho.mqtt.rust.git",children:"paho-mqtt client library"})," in a Rust project, and implement ",(0,s.jsx)(e.code,{children:"connect"}),", ",(0,s.jsx)(e.code,{children:"subscribe"}),", ",(0,s.jsx)(e.code,{children:"messaging"})," and ",(0,s.jsx)(e.code,{children:"unsubscribe"}),", etc., between the client and MQTT broker."]}),"\n",(0,s.jsx)(e.h3,{id:"initialisation-the-project",children:"Initialisation the Project"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"paho-mqtt"})," is the most versatile and widely used MQTT client in the current Rust. The current ",(0,s.jsx)(e.a,{href:"https://github.com/eclipse/paho.mqtt.rust/releases/tag/v0.11.1",children:"latest version 0.11.1"})," supports MQTT v5, 3.1.1, 3.1, and also supports data transfer via standard TCP, SSL / TLS, WebSockets, and QoS support 0, 1, 2, etc:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"cargo new mqtt-example\ncd mqtt-example\nnano Cargo.toml\n"})}),"\n",(0,s.jsxs)(e.p,{children:["Edit the Cargo.toml file in the project, and add the address of the ",(0,s.jsx)(e.code,{children:"paho-mqtt"})," library to the dependencies and specify the binary file corresponding to the subscribe, publish code file:"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-toml",children:'[package]\nname = "mqtt-example"\nversion = "0.1.0"\nedition = "2021"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\npaho-mqtt = { git = "https://github.com/eclipse/paho.mqtt.rust.git", branch = "master" }\n\n[[bin]]\nname = "sub"\npath = "src/sub/main.rs"\n\n[[bin]]\nname = "pub"\npath = "src/pub/main.rs"\n'})}),"\n",(0,s.jsx)(e.h3,{id:"mqtt-subscription",children:"MQTT Subscription"}),"\n",(0,s.jsxs)(e.p,{children:["I am going to use an ",(0,s.jsx)(e.a,{href:"https://wiki.instar.com/en/Advanced_User/INSTAR_MQTT_Broker/",children:"INSTAR MQTT Camera"})," as my MQTTv5 Broker:"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Broker IP"}),": ",(0,s.jsx)(e.code,{children:"192.168.2.115"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"MQTT Service Port"}),": ",(0,s.jsx)(e.code,{children:"1883"})]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Broker Login"}),": ",(0,s.jsx)(e.code,{children:"admin/instar"})]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{alt:"Rust - MQTT Hello World",src:t(537014).A+"",width:"1031",height:"693"})}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.em,{children:"src/sub/main.rs"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use std::{\n    env,\n    process,\n    thread,\n    time::Duration\n};\n\nextern crate paho_mqtt as mqtt;\n\nconst DFLT_BROKER:&str = "tcp://192.168.2.115:1883";\nconst DFLT_CLIENT:&str = "rust_subscribe";\nconst DFLT_TOPICS:&[&str] = &["rust/mqtt", "rust/test"];\n// The qos list that match topics above.\nconst DFLT_QOS:&[i32] = &[0, 1];\n\n// Reconnect to the broker when connection is lost.\nfn try_reconnect(cli: &mqtt::Client) -> bool\n{\n    println!("Connection lost. Waiting to retry connection");\n    for _ in 0..12 {\n        thread::sleep(Duration::from_millis(5000));\n        if cli.reconnect().is_ok() {\n            println!("Successfully reconnected");\n            return true;\n        }\n    }\n    println!("Unable to reconnect after several attempts.");\n    false\n}\n\n// Subscribes to multiple topics.\nfn subscribe_topics(cli: &mqtt::Client) {\n    if let Err(e) = cli.subscribe_many(DFLT_TOPICS, DFLT_QOS) {\n        println!("Error subscribes topics: {:?}", e);\n        process::exit(1);\n    }\n}\n\nfn main() {\n    let host = env::args().nth(1).unwrap_or_else(||\n        DFLT_BROKER.to_string()\n    );\n\n    // Define the set of options for the create.\n    // Use an ID for a persistent session.\n    let create_opts = mqtt::CreateOptionsBuilder::new()\n        .server_uri(host)\n        .client_id(DFLT_CLIENT.to_string())\n        .finalize();\n\n    // Create a client.\n    let mut cli = mqtt::Client::new(create_opts).unwrap_or_else(|err| {\n        println!("Error creating the client: {:?}", err);\n        process::exit(1);\n    });\n\n    // Initialize the consumer before connecting.\n    let rx = cli.start_consuming();\n\n    // Define the set of options for the connection.\n    let lwt = mqtt::MessageBuilder::new()\n        .topic("test")\n        .payload("Consumer lost connection")\n        .finalize();\n    let conn_opts = mqtt::ConnectOptionsBuilder::new()\n        .keep_alive_interval(Duration::from_secs(20))\n        .clean_session(false)\n        .will_message(lwt)\n        .finalize();\n\n    // Connect and wait for it to complete or fail.\n    if let Err(e) = cli.connect(conn_opts) {\n        println!("Unable to connect:\\n\\t{:?}", e);\n        process::exit(1);\n    }\n\n    // Subscribe topics.\n    subscribe_topics(&cli);\n\n    println!("Processing requests...");\n    for msg in rx.iter() {\n        if let Some(msg) = msg {\n            println!("{}", msg);\n        }\n        else if !cli.is_connected() {\n            if try_reconnect(&cli) {\n                println!("Resubscribe topics...");\n                subscribe_topics(&cli);\n            } else {\n                break;\n            }\n        }\n    }\n\n    // If still connected, then disconnect now.\n    if cli.is_connected() {\n        println!("Disconnecting");\n        cli.unsubscribe_many(DFLT_TOPICS).unwrap();\n        cli.disconnect(None).unwrap();\n    }\n    println!("Exiting");\n}\n\n'})}),"\n",(0,s.jsx)(e.h3,{id:"mqtt-publication",children:"MQTT Publication"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.em,{children:"src/pub/main.rs"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-rust",children:'use std::{\n    env,\n    process,\n    time::Duration\n};\n\nextern crate paho_mqtt as mqtt;\n\nconst DFLT_BROKER:&str = "tcp://192.168.2.115:1883";\nconst DFLT_CLIENT:&str = "rust_publish";\nconst DFLT_TOPICS:&[&str] = &["rust/mqtt", "rust/test"];\n// Define the qos.\nconst QOS:i32 = 1;\n\nfn main() {\n    let host = env::args().nth(1).unwrap_or_else(||\n        DFLT_BROKER.to_string()\n    );\n\n    // Define the set of options for the create.\n    // Use an ID for a persistent session.\n    let create_opts = mqtt::CreateOptionsBuilder::new()\n        .server_uri(host)\n        .client_id(DFLT_CLIENT.to_string())\n        .finalize();\n\n    // Create a client.\n    let cli = mqtt::Client::new(create_opts).unwrap_or_else(|err| {\n        println!("Error creating the client: {:?}", err);\n        process::exit(1);\n    });\n\n    // Define the set of options for the connection.\n    let conn_opts = mqtt::ConnectOptionsBuilder::new()\n        .keep_alive_interval(Duration::from_secs(20))\n        .clean_session(true)\n        .finalize();\n\n    // Connect and wait for it to complete or fail.\n    if let Err(e) = cli.connect(conn_opts) {\n        println!("Unable to connect:\\n\\t{:?}", e);\n        process::exit(1);\n    }\n\n    // Create a message and publish it.\n    // Publish message to \'test\' and \'hello\' topics.\n    for num in 0..5 {\n        let content =  "Hello world! ".to_string() + &num.to_string();\n        let mut msg = mqtt::Message::new(DFLT_TOPICS[0], content.clone(), QOS);\n        if num % 2 == 0 {\n            println!("Publishing messages on the {:?} topic", DFLT_TOPICS[1]);\n            msg = mqtt::Message::new(DFLT_TOPICS[1], content.clone(), QOS);\n        } else {\n            println!("Publishing messages on the {:?} topic", DFLT_TOPICS[0]);\n        }\n        let tok = cli.publish(msg);\n\n                if let Err(e) = tok {\n                        println!("Error sending message: {:?}", e);\n                        break;\n                }\n    }\n\n\n    // Disconnect from the broker.\n    let tok = cli.disconnect(None);\n    println!("Disconnect from the broker");\n    tok.unwrap();\n}\n'})}),"\n",(0,s.jsx)(e.h3,{id:"compile-binary-files",children:"Compile Binary Files"}),"\n",(0,s.jsx)(e.p,{children:"The following command generates the sub, pub binary file in the mqtt-example/target/debug directory:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"cargo build\n    Finished dev [unoptimized + debuginfo] target(s) in 0.07s\n"})}),"\n",(0,s.jsx)(e.p,{children:"Execute the sub binary file and wait for the message to be published."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"./sub\nUnable to connect:\n        Paho(-1)\n"})}),"\n",(0,s.jsx)(e.p,{children:"Executing the pub binary file, you can see that messages have been published to the topics rust/test and rust/mqtt, respectively."}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-bash",children:"./pub\nUnable to connect:\n        Paho(-1)\n"})})]})}function u(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},537014:(n,e,t)=>{t.d(e,{A:()=>s});const s=t.p+"assets/images/Rust_MQTT_Hello_World_01-68435046037215dc6dc8ad7c87b5b34c.png"},231413:(n,e,t)=>{t.d(e,{A:()=>s});const s=t.p+"assets/images/photo-kt443t6d_64hdh43hfh6dgjdfhg4_d-4dda98a4eb3b498839926e0b6a5039aa.jpg"},28453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>l});var s=t(296540);const i={},r=s.createContext(i);function o(n){const e=s.useContext(r);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:o(n.components),s.createElement(r.Provider,{value:e},n.children)}}}]);