"use strict";(self.webpackChunkmikes_dev_notebook=self.webpackChunkmikes_dev_notebook||[]).push([[86131],{732941:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var r=t(474848),a=t(28453);const i={sidebar_position:6030,slug:"2021-12-10",title:"OpenCV Optical Flow Algorithm for Object Tracking",authors:"mpolinowski",tags:["Machine Learning","Python","OpenCV"]},o=void 0,s={id:"IoT-and-Machine-Learning/ML/2021-12-10--opencv-optical-flow-tracking/index",title:"OpenCV Optical Flow Algorithm for Object Tracking",description:"Shenzhen, China",source:"@site/docs/IoT-and-Machine-Learning/ML/2021-12-10--opencv-optical-flow-tracking/index.md",sourceDirName:"IoT-and-Machine-Learning/ML/2021-12-10--opencv-optical-flow-tracking",slug:"/IoT-and-Machine-Learning/ML/2021-12-10--opencv-optical-flow-tracking/2021-12-10",permalink:"/docs/IoT-and-Machine-Learning/ML/2021-12-10--opencv-optical-flow-tracking/2021-12-10",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/IoT-and-Machine-Learning/ML/2021-12-10--opencv-optical-flow-tracking/index.md",tags:[{label:"Machine Learning",permalink:"/docs/tags/machine-learning"},{label:"Python",permalink:"/docs/tags/python"},{label:"OpenCV",permalink:"/docs/tags/open-cv"}],version:"current",sidebarPosition:6030,frontMatter:{sidebar_position:6030,slug:"2021-12-10",title:"OpenCV Optical Flow Algorithm for Object Tracking",authors:"mpolinowski",tags:["Machine Learning","Python","OpenCV"]},sidebar:"tutorialSidebar",previous:{title:"Yolo App - Data Collection",permalink:"/docs/IoT-and-Machine-Learning/ML/2022-02-15--yolo-app-get-data/2022-02-15"},next:{title:"OpenCV CAMshift Algorithm for Object Tracking",permalink:"/docs/IoT-and-Machine-Learning/ML/2021-12-09--opencv-camshift-tracking/2021-12-09"}},c={},l=[{value:"Optical Flow (Sparse)",id:"optical-flow-sparse",level:2},{value:"Get your Video",id:"get-your-video",level:3},{value:"Auto Select Object to Track",id:"auto-select-object-to-track",level:3},{value:"Manually Select Object to Track",id:"manually-select-object-to-track",level:3},{value:"Optical Flow (Dense)",id:"optical-flow-dense",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Shenzhen, China",src:t(459467).A+"",width:"2385",height:"919"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"#optical-flow-sparse",children:"Optical Flow (Sparse)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#get-your-video",children:"Get your Video"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#auto-select-object-to-track",children:"Auto Select Object to Track"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#manually-select-object-to-track",children:"Manually Select Object to Track"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"#optical-flow-dense",children:"Optical Flow (Dense)"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://github.com/mpolinowski/opencv2-tracking-algorithm",children:"Github Repo"})}),"\n",(0,r.jsxs)(n.p,{children:["One of the problems with the ",(0,r.jsx)(n.a,{href:"/docs/IoT-and-Machine-Learning/ML/2021-12-08--opencv-meanshift-tracking/2021-12-08",children:"Meanshift Algorithm"})," was that the region of interest always stayed at the same size when the object came closer to the camera or moved farther away. The region needs to adapt it's size with size and rotation of the target. This was remedied by the ",(0,r.jsx)(n.a,{href:"/docs/IoT-and-Machine-Learning/ML/2021-12-09--opencv-camshift-tracking/2021-12-09",children:"CAMShift Algorithm"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://docs.opencv.org/4.x/d4/dee/tutorial_optical_flow.html",children:"Optical flow"})," is the pattern of apparent motion of image objects between two consecutive frames caused by the movement of object or camera. It is 2D vector field where each vector is a displacement vector showing the movement of points from first frame to second."]}),"\n",(0,r.jsx)(n.h2,{id:"optical-flow-sparse",children:"Optical Flow (Sparse)"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://docs.opencv.org/4.x/d4/dee/tutorial_optical_flow.html",children:"Optical flow"})," is the pattern of apparent motion of image objects between two consecutive frames caused by the movement of object or camera. It is 2D vector field where each vector is a displacement vector showing the movement of points from first frame to second."]}),"\n",(0,r.jsx)(n.h3,{id:"get-your-video",children:"Get your Video"}),"\n",(0,r.jsx)(n.p,{children:"Get your video file input:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"cap = cv2.VideoCapture('resources/group_of_people_02.mp4')\r\n# get first video frame\r\nok, frame = cap.read()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"auto-select-object-to-track",children:"Auto Select Object to Track"}),"\n",(0,r.jsxs)(n.p,{children:["I want to use the ",(0,r.jsx)(n.a,{href:"https://docs.opencv.org/4.x/d4/d8c/tutorial_py_shi_tomasi.html",children:"Shi-Tomasi Corner Detector"})," which is used by the OpenCV ",(0,r.jsx)(n.code,{children:"Good Features to Track"})," function to detect the corner points of an object. As usual, image should be a grayscale image. Then you specify number of corners you want to find. Then you specify the quality level, which is a value between 0-1, which denotes the minimum quality of corner below which everyone is rejected. Then we provide the minimum euclidean distance between corners detected:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# generate initial corners of detected object\r\n# set limit, minimum distance in pixels and quality of object corner to be tracked\r\nparameters_shitomasi = dict(maxCorners=100, qualityLevel=0.3, minDistance=7)\n"})}),"\n",(0,r.jsx)(n.p,{children:"With all this information, the function finds corners in the image. All corners below quality level are rejected. Then it sorts the remaining corners based on quality in the descending order. Then function takes first strongest corner, throws away all the nearby corners in the range of minimum distance and returns N strongest corners:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# convert to grayscale\r\nframe_gray_init = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\r\n\r\n# Use Shi-Tomasi to detect object corners / edges from initial frame\r\nedges = cv2.goodFeaturesToTrack(frame_gray_init, mask = None, **parameters_shitomasi)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Now that we have the ",(0,r.jsx)(n.code,{children:"edges"})," - corner points - of all detected objects in the initial frame wen can start comparing consecutive frames of the video to this initial frame and edges. But one more thing - we need to create a clean sheet to draw our detection lines on and a random colour generator for those lines:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# create a black canvas the size of the initial frame\r\ncanvas = np.zeros_like(frame)\r\n# create random colours for visualization for all 100 max corners for RGB channels\r\ncolours = np.random.randint(0, 255, (100, 3))\n"})}),"\n",(0,r.jsxs)(n.p,{children:["And now we can loop through the following video frames, comparing each one to the initial detection. The while loop uses the ",(0,r.jsx)(n.a,{href:"https://docs.opencv.org/3.4.15/d7/d08/classcv_1_1SparsePyrLKOpticalFlow.html",children:"cv2.calcOpticalFlowPyrLK"})," function that ",(0,r.jsx)(n.a,{href:"https://docs.opencv.org/3.4.15/dc/d6b/group__video__track.html#ga473e4b886d0bcc6b65831eb88ed93323",children:"needs to be configured with the following parameter"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# set min size of tracked object, e.g. 15x15px\r\nparameter_lucas_kanade = dict(winSize=(15, 15), maxLevel=2, criteria=(cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 10, 0.03))\n"})}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Parameters"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"winSize"}),(0,r.jsx)(n.td,{children:"size of the search window at each pyramid level."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"maxLevel"}),(0,r.jsx)(n.td,{children:"0-based maximal pyramid level number; if set to 0, pyramids are not used (single level), if set to 1, two levels are used, and so on; if pyramids are passed to input then algorithm will use as many levels as pyramids have but no more than maxLevel."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"criteria"}),(0,r.jsx)(n.td,{children:"parameter, specifying the termination criteria of the iterative search algorithm (after the specified maximum number of iterations criteria.maxCount or when the search window moves by less than criteria.epsilon."})]})]})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"while True:\r\n    # get next frame\r\n    ok, frame = cap.read()\r\n    if not ok:\r\n        print(\"[INFO] end of file reached\")\r\n        break\r\n    # prepare grayscale image\r\n    frame_gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\r\n    # update object corners by comparing with found edges in initial frame\r\n    update_edges, status, errors = cv2.calcOpticalFlowPyrLK(frame_gray_init, frame_gray, edges, None,\r\n                                                         **parameter_lucas_kanade)\r\n    # only update edges if algorithm successfully tracked\r\n    new_edges = update_edges[status == 1]\r\n    # to calculate directional flow we need to compare with previous position\r\n    old_edges = edges[status == 1]\r\n\r\n    for i, (new, old) in enumerate(zip(new_edges, old_edges)):\r\n        a, b = new.ravel()\r\n        c, d = old.ravel()\r\n\r\n        # draw line between old and new corner point with random colour\r\n        mask = cv2.line(canvas, (int(a), int(b)), (int(c), int(d)), colours[i].tolist(), 2)\r\n        # draw circle around new position\r\n        frame = cv2.circle(frame, (int(a), int(b)), 5, colours[i].tolist(), -1)\r\n\r\n    result = cv2.add(frame, mask)\r\n    cv2.imshow('Optical Flow (sparse)', result)\r\n    if cv2.waitKey(1) & 0xFF == ord('q'):\r\n        break\r\n    # overwrite initial frame with current before restarting the loop\r\n    frame_gray_init = frame_gray.copy()\r\n    # update to new edges before restarting the loop\r\n    edges = new_edges.reshape(-1, 1, 2)\n"})}),"\n",(0,r.jsx)(n.p,{children:"The result looks like:"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"OpenCV Meanshift Algorithm for Object Tracking",src:t(917187).A+"",width:"670",height:"191"})}),"\n",(0,r.jsx)(n.h3,{id:"manually-select-object-to-track",children:"Manually Select Object to Track"}),"\n",(0,r.jsxs)(n.p,{children:["The auto-selection works OK in the example above. But it can quickly become messy in crowded spaces. Here you might want to select the starting point of your track yourself. So let's create a function that is automatically called when a window with the name ",(0,r.jsx)(n.code,{children:"Optical Flow"})," is created and that listens to your left mouse-button. Whenever you click the frame displayed inside the window the coordinates of your cursor are recorded and the algorithm tries to track the underlying edge point of your selected object:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# define function to manually select object to track\r\ndef select_point(event, x, y, flags, params):\r\n    global point, selected_point, old_points\r\n    # record coordinates of mouse click\r\n    if event == cv2.EVENT_LBUTTONDOWN:\r\n        point = (x, y)\r\n        selected_point = True\r\n        old_points = np.array([[x, y]], dtype=np.float32)\r\n\r\n\r\n# associate select function with window Selector\r\ncv2.namedWindow('Optical Flow')\r\ncv2.setMouseCallback('Optical Flow', select_point)\r\n\r\n# initialize variables updated by function\r\nselected_point = False\r\npoint = ()\r\nold_points = ([[]])\n"})}),"\n",(0,r.jsx)(n.p,{children:"And again we need to loop through the remaining frames applying the Sparse Optical Flow algorithm to track the object:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# loop through the remaining frames of the video\r\n# and apply algorithm to track selected objects\r\nwhile True:\r\n    # get next frame\r\n    frame = vs.read()\r\n    # covert to grayscale\r\n    frame_gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\r\n\r\n    if selected_point is True:\r\n        cv2.circle(frame, point, 5, (0, 0, 255), 2)\r\n        # update object corners by comparing with found edges in initial frame\r\n        new_points, status, errors = cv2.calcOpticalFlowPyrLK(frame_gray_init, frame_gray, old_points, None,\r\n                                                         **parameter_lucas_kanade)\r\n\r\n        # overwrite initial frame with current before restarting the loop\r\n        frame_gray_init = frame_gray.copy()\r\n        # update to new edges before restarting the loop\r\n        old_points = new_points\r\n\r\n        x, y = new_points.ravel()\r\n        j, k = old_points.ravel()\r\n\r\n        # draw line between old and new corner point with random colour\r\n        canvas = cv2.line(canvas, (int(x), int(y)), (int(j), int(k)), (0, 255, 0), 3)\r\n        # draw circle around new position\r\n        frame = cv2.circle(frame, (int(x), int(y)), 5, (0, 255, 0), -1)\r\n\r\n    result = cv2.add(frame, canvas)\r\n    cv2.imshow('Optical Flow', result)\r\n    if cv2.waitKey(1) & 0xFF == ord('q'):\r\n        break\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"OpenCV Meanshift Algorithm for Object Tracking",src:t(181948).A+"",width:"741",height:"295"})}),"\n",(0,r.jsx)(n.h2,{id:"optical-flow-dense",children:"Optical Flow (Dense)"}),"\n",(0,r.jsx)(n.p,{children:"Lucas-Kanade method computes optical flow for a sparse feature set (in our example, corners detected using Shi-Tomasi algorithm). OpenCV provides another algorithm to find the dense optical flow. It computes the optical flow for all the points in the frame."}),"\n",(0,r.jsx)(n.p,{children:"There is only one change outside of the while-loop compared to sparse flow - we need to define our canvas in the HSV colour space and initialize it with maximum saturation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# create canvas to paint on\r\nhsv_canvas = np.zeros_like(first_frame)\r\n# set saturation value (position 2 in HSV space) to 255\r\nhsv_canvas[..., 1] = 255\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Again, we need to grab the following frames from our video and compare the current frame with the initial frame. The function in OpenCV is called ",(0,r.jsx)(n.a,{href:"https://docs.opencv.org/4.x/dc/d6b/group__video__track.html#ga5d10ebbd59fe09c5f650289ec0ece5af",children:"cv2.calcOpticalFlowFarneback()"})," and uses the following configuration parameters:"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Parameters"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"prev"}),(0,r.jsx)(n.td,{children:"first 8-bit single-channel input image."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"next"}),(0,r.jsx)(n.td,{children:"second input image of the same size and the same type as prev."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"flow"}),(0,r.jsx)(n.td,{children:"computed flow image that has the same size as prev and type CV_32FC2."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"pyr_scale"}),(0,r.jsx)(n.td,{children:"parameter, specifying the image scale (< 1) to build pyramids for each image; pyr_scale=0.5 means a classical pyramid, where each next layer is twice smaller than the previous one."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"levels"}),(0,r.jsx)(n.td,{children:"number of pyramid layers including the initial image; levels=1 means that no extra layers are created and only the original images are used."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"winsize"}),(0,r.jsx)(n.td,{children:"averaging window size; larger values increase the algorithm robustness to image noise and give more chances for fast motion detection, but yield more blurred motion field."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"iterations"}),(0,r.jsx)(n.td,{children:"number of iterations the algorithm does at each pyramid level."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"poly_n"}),(0,r.jsx)(n.td,{children:"size of the pixel neighborhood used to find polynomial expansion in each pixel; larger values mean that the image will be approximated with smoother surfaces, yielding more robust algorithm and more blurred motion field, typically poly_n =5 or 7."})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"poly_sigma"}),(0,r.jsx)(n.td,{children:"standard deviation of the Gaussian that is used to smooth derivatives used as a basis for the polynomial expansion; for poly_n=5, you can set poly_sigma=1.1, for poly_n=7, a good value would be poly_sigma=1.5."})]})]})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"while True:\r\n    # get next frame\r\n    ok, frame = cap.read()\r\n    if not ok:\r\n        print(\"[ERROR] reached end of file\")\r\n        break\r\n    frame_gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\r\n    # compare initial frame with current frame\r\n    flow = cv2.calcOpticalFlowFarneback(frame_gray_init, frame_gray, None, 0.5, 3, 15, 3, 5, 1.1, 0)\r\n    # get x and y coordinates\r\n    magnitude, angle = cv2.cartToPolar(flow[..., 0], flow[..., 1])\r\n    # set hue of HSV canvas (position 1)\r\n    hsv_canvas[..., 0] = angle*(180/(np.pi/2))\r\n    # set pixel intensity value (position 3\r\n    hsv_canvas[..., 2] = cv2.normalize(magnitude, None, 0, 255, cv2.NORM_MINMAX)\r\n\r\n    frame_rgb = cv2.cvtColor(hsv_canvas, cv2.COLOR_HSV2BGR)\r\n\r\n    # optional recording result/mask\r\n    video_output.write(frame_rgb)\r\n\r\n    cv2.imshow('Optical Flow (dense)', frame_rgb)\r\n    if cv2.waitKey(1) & 0xFF == ord('q'):\r\n        break\r\n\r\n    # set initial frame to current frame\r\n    frame_gray_init = frame_gray\n"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"OpenCV Meanshift Algorithm for Object Tracking",src:t(396565).A+"",width:"657",height:"184"})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},917187:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/OpenCV_Optical_Flow_Tracking_01-847bf512368f7ffccaeff5691c3e0c05.gif"},181948:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/OpenCV_Optical_Flow_Tracking_02-16a87e22e9c00167718cbf544c54e5c9.gif"},396565:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/OpenCV_Optical_Flow_Tracking_03-4579858a7dfd480cce75818e6ecc04ea.gif"},459467:(e,n,t)=>{t.d(n,{A:()=>r});const r=t.p+"assets/images/photo-kt443t6d_64hdh43hfh6dgjdfhg4_d-5a0b68587d9242bbb46a1f1aaab44216.jpg"},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var r=t(296540);const a={},i=r.createContext(a);function o(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);