"use strict";(self.webpackChunkmikes_dev_notebook=self.webpackChunkmikes_dev_notebook||[]).push([[77956],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),c=d(n),m=r,h=c["".concat(l,".").concat(m)]||c[m]||u[m]||o;return n?a.createElement(h,s(s({ref:t},p),{},{components:n})):a.createElement(h,s({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=c;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var d=2;d<o;d++)s[d]=n[d];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},12944:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>d});var a=n(87462),r=(n(67294),n(3905));const o={sidebar_position:4720,slug:"2023-01-31",title:"Python Ray Model Serving",authors:"mpolinowski",tags:["Python","Machine Learning","Ray"],description:"Using Ray Serve for ML Model Serving."},s=void 0,i={unversionedId:"IoT-and-Machine-Learning/AIOps/2023-01-31-python-ray-model-serving/index",id:"IoT-and-Machine-Learning/AIOps/2023-01-31-python-ray-model-serving/index",title:"Python Ray Model Serving",description:"Using Ray Serve for ML Model Serving.",source:"@site/docs/IoT-and-Machine-Learning/AIOps/2023-01-31-python-ray-model-serving/index.md",sourceDirName:"IoT-and-Machine-Learning/AIOps/2023-01-31-python-ray-model-serving",slug:"/IoT-and-Machine-Learning/AIOps/2023-01-31-python-ray-model-serving/2023-01-31",permalink:"/docs/IoT-and-Machine-Learning/AIOps/2023-01-31-python-ray-model-serving/2023-01-31",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/IoT-and-Machine-Learning/AIOps/2023-01-31-python-ray-model-serving/index.md",tags:[{label:"Python",permalink:"/docs/tags/python"},{label:"Machine Learning",permalink:"/docs/tags/machine-learning"},{label:"Ray",permalink:"/docs/tags/ray"}],version:"current",sidebarPosition:4720,frontMatter:{sidebar_position:4720,slug:"2023-01-31",title:"Python Ray Model Serving",authors:"mpolinowski",tags:["Python","Machine Learning","Ray"],description:"Using Ray Serve for ML Model Serving."},sidebar:"tutorialSidebar",previous:{title:"Apache Airflow Introduction",permalink:"/docs/IoT-and-Machine-Learning/AIOps/2023-02-01-apache-airflow-introduction/2023-02-01"},next:{title:"Python Ray Deployments",permalink:"/docs/IoT-and-Machine-Learning/AIOps/2023-01-29-python-ray-deployments/2023-01-29"}},l={},d=[{value:"Export the trained Classifier Models",id:"export-the-trained-classifier-models",level:2},{value:"Serving the Models",id:"serving-the-models",level:2},{value:"Speculative Model Serving",id:"speculative-model-serving",level:2}],p={toc:d};function u(e){let{components:t,...o}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Guangzhou, China",src:n(70220).Z,width:"1500",height:"662"})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#export-the-trained-classifier-models"},"Export the trained Classifier Models")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#serving-the-models"},"Serving the Models")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#speculative-model-serving"},"Speculative Model Serving"))),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Source: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/scalingpythonml/scaling-python-with-ray"},"Scaling Python with Ray"))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/mpolinowski/ray-serve-model"},"Github Repository"))),(0,r.kt)("p",null,"I earlier looked at ",(0,r.kt)("a",{parentName:"p",href:"/docs/IoT-and-Machine-Learning/ML/2023-01-30-predicting-wine-quality/2023-01-30"},"Wine Dataset")," and used a couple of ",(0,r.kt)("strong",{parentName:"p"},"SciKit Learn Classifier")," to fit different models to this data to make a binary classification ",(0,r.kt)("em",{parentName:"p"},'"Is this wine any good?"')," based on a set of features provided by the dataset."),(0,r.kt)("h2",{id:"export-the-trained-classifier-models"},"Export the trained Classifier Models"),(0,r.kt)("p",null,"To be able to ",(0,r.kt)("a",{parentName:"p",href:"https://docs.ray.io/en/latest/serve/tutorials/serve-ml-models.html"},"serve such a model in Ray")," we need to export it using ",(0,r.kt)("strong",{parentName:"p"},"Pickle"),". Since we already found that only the ",(0,r.kt)("strong",{parentName:"p"},"Random Forrest")," and the ",(0,r.kt)("strong",{parentName:"p"},"XGBoost Classifier")," give us usable results we only need to export those by adding the following code (don't forget to ",(0,r.kt)("inlineCode",{parentName:"p"},"import pickle"),") to the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/mpolinowski/scikit-wine-quality/blob/master/main.py"},"training file"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'# DEPLOY MODELS\n\nRANDOM_FOREST_WHITE_MODEL_PATH = os.path.join("models/wine-white-quality_random_forest.pkl")\nRANDOM_FOREST_RED_MODEL_PATH = os.path.join("models/wine-red-quality_random_forest.pkl")\nXGBOOST_WHITE_MODEL_PATH = os.path.join("models/wine-white-quality_xgboost.pkl")\nXGBOOST_RED_MODEL_PATH = os.path.join("models/wine-red-quality_xgboost.pkl")\n\nXGBoostModelRed.deploy(XGBOOST_RED_MODEL_PATH)\nXGBoostModelWhite.deploy(XGBOOST_WHITE_MODEL_PATH)\nRandomForestModelRed.deploy(RANDOM_FOREST_RED_MODEL_PATH)\nRandomForestModelWhite.deploy(RANDOM_FOREST_WHITE_MODEL_PATH)\n')),(0,r.kt)("h2",{id:"serving-the-models"},"Serving the Models"),(0,r.kt)("p",null,"As in our ",(0,r.kt)("a",{parentName:"p",href:"/docs/IoT-and-Machine-Learning/AIOps/2023-01-29-python-ray-deployments/2023-01-29"},"previous deployments")," we now have to use ",(0,r.kt)("inlineCode",{parentName:"p"},"@serve.deployment")," to define a Ray remote actor that loads our exported model and, defines the API (",(0,r.kt)("em",{parentName:"p"},"what feature inputs does the model expect"),") and then run predictions based on incoming API requests:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'# XGBOOST - RED WINE\n\n#define deployment\n@serve.deployment(route_prefix="/xgboost/red_wines")\nclass XGBoostModelRed:\n    def __init__(self, path):\n        with open(path, "rb") as f:\n            self.model = pickle.load(f)\n\n    async def __call__(self, request):\n        payload = await request.json()\n        return self.serve(payload)\n\n    def serve(self, request):\n        model_features = np.array([\n            request["fixed acidity"],\n            request["volatile acidity"],\n            request["citric acid"],\n            request["residual sugar"],\n            request["chlorides"],\n            request["free sulfur dioxide"],\n            request["total sulfur dioxide"],\n            request["density"],\n            request["pH"],\n            request["sulphates"],\n            request["alcohol"],\n        ])\n        prediction = self.model.predict(model_features.reshape(1,11))[0]\n        return {"result": str(prediction)}\n\nXGBoostModelRed.deploy(XGBOOST_RED_MODEL_PATH)\n')),(0,r.kt)("p",null,"For the prediction I pretend that I received a CSV file with measurements, load them into a dataframe and run the same scaler on them as I did for the trainings data:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'# normalize prediction example\ndf_input = pd.read_csv("data/prediction_example.csv")\ndf_norm = StandardScaler().fit_transform(df_input)\n')),(0,r.kt)("p",null,"Now I can prepare an API request to my prediction service by taking the first row of the file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'sample_request_input_red = {\n    "fixed acidity": df_norm[0][0],\n    "volatile acidity": df_norm[0][1],\n    "citric acid": df_norm[0][2],\n    "residual sugar": df_norm[0][3],\n    "chlorides": df_norm[0][4],\n    "free sulfur dioxide":  df_norm[0][5],\n    "total sulfur dioxide": df_norm[0][6],\n    "density": df_norm[0][7],\n    "pH": df_norm[0][8],\n    "sulphates": df_norm[0][9],\n    "alcohol":  df_norm[0][10],\n}\n')),(0,r.kt)("p",null,"Since this measurement came from a red wine I will run it against a model trained on red wine data:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'print(requests.get("http://localhost:8000/xgboost/red_wines", json=sample_request_input_red).text)\n')),(0,r.kt)("p",null,"As a result I will receive either a ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"1")," - the latter meaning that the quality of this wine was judged to be a 7 out of 10 or better:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'{"result": "1"}\n')),(0,r.kt)("h2",{id:"speculative-model-serving"},"Speculative Model Serving"),(0,r.kt)("p",null,"Speculative Model Serving is an optimization technique where a computer system performs some task that may not be needed. Work is done before it is known whether it is actually needed, so as to prevent a delay that would have to be incurred by doing the work after it is known that it is needed."),(0,r.kt)("p",null,"This technique can be used to build a ",(0,r.kt)("strong",{parentName:"p"},"Consensus-based Model Serving"),". I, currently, I only use two models - this example would make more sense if I ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/scalingpythonml/scaling-python-with-ray/blob/22f413fe140255dd37274a08a89679c8194029b1/examples/ray_examples/serving/modelserving/model_server_deployments.py"},"had at least 3"),". But we can still build a prediction API that only returns a result if both models agree on the result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-py"},'@serve.deployment(route_prefix="/speculative")\nclass Speculative:\n    def __init__(self):\n        self.rfhandle = RandomForestModel.get_handle(sync=False)\n        self.xgboosthandle = XGBoostModel.get_handle(sync=False)\n    async def __call__(self, request):\n        payload = await request.json()\n        f1, f2 = await asyncio.gather(self.rfhandle.serve.remote(payload),\n                self.xgboosthandle.serve.remote(payload))\n\n        rfresurlt = ray.get(f1)[\'result\']\n        xgresurlt = ray.get(f2)[\'result\']\n        ones = []\n        zeros = []\n        if rfresurlt == "1":\n            ones.append("Random forest")\n        else:\n            zeros.append("Random forest")\n        if xgresurlt == "1":\n            ones.append("XGBoost")\n        else:\n            zeros.append("XGBoost")\n        if len(ones) >= 2:\n            return {"result": "1", "methods": ones}\n        else:\n            return {"result": "0", "methods": zeros}\n')),(0,r.kt)("p",null,"The call method here gets the payload and starts executing all three models in parallel and then waits for all to complete.  Once all the results are in, the consensus is calculated and the result returned along with methods that voted for it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},':: Random Forrest Classifier - Red Wines ::\n\n{"result": "1"}\n\n:: XGBoost Classifier - Red Wines ::\n\n{"result": "1"}\n\n:: Consensus Results ::\n\n{"result": "1", "methods": ["Random forest", "XGBoost"]}\n')))}u.isMDXComponent=!0},70220:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/photo-kt443t6d_64hdh43hfh6dgjdfhg4_d-296769d73822f07b0ac5dc952f56bfa1.jpg"}}]);