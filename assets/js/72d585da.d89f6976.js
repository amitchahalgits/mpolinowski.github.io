"use strict";(self.webpackChunkmikes_dev_notebook=self.webpackChunkmikes_dev_notebook||[]).push([[48397],{3905:(e,t,n)=>{n.d(t,{Zo:()=>f,kt:()=>p});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},f=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,f=l(e,["components","mdxType","originalType","parentName"]),c=u(n),p=a,d=c["".concat(s,".").concat(p)]||c[p]||m[p]||o;return n?r.createElement(d,i(i({ref:t},f),{},{components:n})):r.createElement(d,i({ref:t},f))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var u=2;u<o;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},20231:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var r=n(87462),a=(n(67294),n(3905));const o={sidebar_position:4750,slug:"2023-01-23",title:"Python Ray Remote Functions",authors:"mpolinowski",tags:["Python","Machine Learning","Ray"],description:"Remote functions can be run in a separate process on the local machine - spreading out the workload over several cores. Or can be executed on remote machines in your server cluster."},i=void 0,l={unversionedId:"IoT-and-Machine-Learning/AIOps/2023-01-23-python-ray-remote-functions/index",id:"IoT-and-Machine-Learning/AIOps/2023-01-23-python-ray-remote-functions/index",title:"Python Ray Remote Functions",description:"Remote functions can be run in a separate process on the local machine - spreading out the workload over several cores. Or can be executed on remote machines in your server cluster.",source:"@site/docs/IoT-and-Machine-Learning/AIOps/2023-01-23-python-ray-remote-functions/index.md",sourceDirName:"IoT-and-Machine-Learning/AIOps/2023-01-23-python-ray-remote-functions",slug:"/IoT-and-Machine-Learning/AIOps/2023-01-23-python-ray-remote-functions/2023-01-23",permalink:"/docs/IoT-and-Machine-Learning/AIOps/2023-01-23-python-ray-remote-functions/2023-01-23",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/IoT-and-Machine-Learning/AIOps/2023-01-23-python-ray-remote-functions/index.md",tags:[{label:"Python",permalink:"/docs/tags/python"},{label:"Machine Learning",permalink:"/docs/tags/machine-learning"},{label:"Ray",permalink:"/docs/tags/ray"}],version:"current",sidebarPosition:4750,frontMatter:{sidebar_position:4750,slug:"2023-01-23",title:"Python Ray Remote Functions",authors:"mpolinowski",tags:["Python","Machine Learning","Ray"],description:"Remote functions can be run in a separate process on the local machine - spreading out the workload over several cores. Or can be executed on remote machines in your server cluster."},sidebar:"tutorialSidebar",previous:{title:"AIOps",permalink:"/docs/category/aiops"},next:{title:"Python Ray Basic Concepts",permalink:"/docs/IoT-and-Machine-Learning/AIOps/2023-01-22-python-ray-introduction/2023-01-22"}},s={},u=[{value:"Waiting for Results",id:"waiting-for-results",level:2},{value:"Ray GET",id:"ray-get",level:3},{value:"Ray WAIT",id:"ray-wait",level:3},{value:"Optional Parameter",id:"optional-parameter",level:3},{value:"Composition",id:"composition",level:2},{value:"Pipelines",id:"pipelines",level:3},{value:"Nested Parallelism",id:"nested-parallelism",level:3}],f={toc:u};function m(e){let{components:t,...o}=e;return(0,a.kt)("wrapper",(0,r.Z)({},f,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Guangzhou, China",src:n(97572).Z,width:"1500",height:"662"})),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#waiting-for-results"},"Waiting for Results"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#ray-get"},"Ray GET")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#ray-wait"},"Ray WAIT")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#optional-parameter"},"Optional Parameter")))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#composition"},"Composition"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#pipelines"},"Pipelines")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#nested-parallelism"},"Nested Parallelism"))))),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Source: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/scalingpythonml/scaling-python-with-ray"},"Scaling Python with Ray"))),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/mpolinowski/ray-remote-functions"},"Github Repository"))),(0,a.kt)("p",null,"Ray lets you ",(0,a.kt)("strong",{parentName:"p"},"run functions as remote tasks")," in the cluster. Remote functions can be run in a separate process on the local machine - spreading out the workload over several cores. Or can be executed on remote machines in your server cluster."),(0,a.kt)("h2",{id:"waiting-for-results"},"Waiting for Results"),(0,a.kt)("p",null,"To execute a function remotely, you have to decorate your function with ",(0,a.kt)("inlineCode",{parentName:"p"},"@ray.remote"),". Then, you call that function with ",(0,a.kt)("inlineCode",{parentName:"p"},".remote()")," instead of calling it normally. This remote call returns a future, a so-called Ray object reference, that you can then fetch with ",(0,a.kt)("inlineCode",{parentName:"p"},"ray.get")," - which will block the process until the result is returned."),(0,a.kt)("p",null,"When working with futures that have different execution times - e.g. ML trainings with different batch-sizes - you should use ",(0,a.kt)("inlineCode",{parentName:"p"},"ray.wait")," instead, which returns the requested number of futures that have already been completed. We can simulate this with a simple variable sleep timer ",(0,a.kt)("inlineCode",{parentName:"p"},"time.sleep(x)"),":"),(0,a.kt)("h3",{id:"ray-get"},"Ray GET"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},'import ray\nimport time\nimport timeit\n\n# simulate remote functions with\n# different execution times\n@ray.remote\ndef remote_task(x):\n    time.sleep(x)\n    return x\n\n# create a list of things\nthings = list(range(10))\n# ensure that the futures won\u2019t complete in order\nthings.sort(reverse=True)\n\n# GET\n\n## get results when all results are available\ndef in_order():\n    ### use remote function to retrieve futures\n    futures = list(map(lambda x: remote_task.remote(x), things))\n    ### ray.get will block your function until all futures are returned\n    values = ray.get(futures)\n    ### loop over results and print\n    for v in values:\n        print(f" Completed {v}")\n        ### simulate some business logic\n        time.sleep(1)\n\n\n# call order and see how long it takes to complete\nprint("GET took: ", timeit.timeit(lambda: in_order(), number=1))\n')),(0,a.kt)("p",null,"Executing this function returns:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"python 01_ray-wait.py\n2023-01-23 13:42:34,328 INFO worker.py:1529 -- Started a local Ray instance.\nView the dashboard at 127.0.0.1:8265 \n Completed 9\n Completed 8\n Completed 7\n Completed 6\n Completed 5\n Completed 4\n Completed 3\n Completed 2\n Completed 1\n Completed 0\nGET took:  22.13837863399931\n")),(0,a.kt)("h3",{id:"ray-wait"},"Ray WAIT"),(0,a.kt)("p",null,"With ",(0,a.kt)("inlineCode",{parentName:"p"},"ray.wait")," we can now process the incoming results as they become available. Since we are simulating some business logic in our local process (",(0,a.kt)("inlineCode",{parentName:"p"},"time.sleep(1)"),") this part can now be executed in parallel with the remote function whenever a new result is returned. This will reduce the overall execution time dramatically:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},'# WAIT\n\n## process as results become available\ndef as_available():\n    ### use remote function to retrieve futures\n    futures = list(map(lambda x: remote_task.remote(x), things))\n    ### while still futures left\n    while len(futures) > 0:\n        ### call ray.wait to get the next future\n        ready_futures, rest_futures = ray.wait(futures)\n        ### show progress\n        print(f"Ready {len(ready_futures)} rest {len(rest_futures)}")\n        ### print results\n        for id in ready_futures:\n            print(f\'completed value {id}, result {ray.get(id)}\')\n            ### simulate some business logic\n            time.sleep(1)\n        ### wait on the ones that are not yet available\n        futures = rest_futures\n\n## call order and see how long it takes to complete\nprint("WAIT took: ", timeit.timeit(lambda: as_available(), number=1))\n')),(0,a.kt)("p",null,"As predicted we get a much shorter overall execution time -  a reduction of ",(0,a.kt)("inlineCode",{parentName:"p"},"~ 45%"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"Ready 1 rest 9\ncompleted value ObjectRef(c54e76759b2a0c10ffffffffffffffffffffffff0100000001000000), result 2\nReady 1 rest 8\ncompleted value ObjectRef(5d4b8d1788f12d2dffffffffffffffffffffffff0100000001000000), result 3\nReady 1 rest 7\ncompleted value ObjectRef(239c2f70c73fbf73ffffffffffffffffffffffff0100000001000000), result 1\nReady 1 rest 6\ncompleted value ObjectRef(71b133a11e1c461cffffffffffffffffffffffff0100000001000000), result 4\nReady 1 rest 5\ncompleted value ObjectRef(1e360ffa862f8fe3ffffffffffffffffffffffff0100000001000000), result 0\nReady 1 rest 4\ncompleted value ObjectRef(d695f922effe6d99ffffffffffffffffffffffff0100000001000000), result 6\nReady 1 rest 3\ncompleted value ObjectRef(85748392bcd969ccffffffffffffffffffffffff0100000001000000), result 7\nReady 1 rest 2\ncompleted value ObjectRef(1e8ff6d236132784ffffffffffffffffffffffff0100000001000000), result 8\nReady 1 rest 1\ncompleted value ObjectRef(359ec6ce30d3ca2dffffffffffffffffffffffff0100000001000000), result 9\nReady 1 rest 0\ncompleted value ObjectRef(2751d69548dba956ffffffffffffffffffffffff0100000001000000), result 5\nWAIT took:  12.03411061800034\n")),(0,a.kt)("h3",{id:"optional-parameter"},"Optional Parameter"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"num_returns"),":  Number of ObjectRef objects for Ray to wait for completion before returning. This is equal or smaller than the length of the input list."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"timeout"),": The maximum amount of time in seconds to wait before returning. This defaults to ",(0,a.kt)("inlineCode",{parentName:"li"},"\u22121")," - ",(0,a.kt)("em",{parentName:"li"},"infinite"),". ",(0,a.kt)("strong",{parentName:"li"},"GET")," will return ",(0,a.kt)("inlineCode",{parentName:"li"},"GetTimeoutError"),". While ",(0,a.kt)("strong",{parentName:"li"},"WAIT")," will just stop waiting for more results."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"fetch_local"),": If set to ",(0,a.kt)("strong",{parentName:"li"},"False")," the results will not be fetched. You only get confirmation that the remote function returned results as expected.")),(0,a.kt)("p",null,"Additionally you can use ",(0,a.kt)("inlineCode",{parentName:"p"},"ray.cancel")," to terminate remotely executed functions - since a timeout will not stop them."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},'## same as above but with timeout and remote cancel\ndef as_available():\n    futures = list(map(lambda x: remote_task.remote(x), things))\n    ### while still futures left\n    while len(futures) > 0:\n        ### call ray.wait to get the next future\n        ### but with a 10s timeout and always collect 5 results before returning anything\n        ready_futures, rest_futures = ray.wait(futures, timeout=10, num_returns=5)\n        # if we get back less than num_returns \n        if len(ready_futures) < 1:\n            print(f"Timed out on {rest_futures}")\n            # cancel remote function, e.g. if task is using a lot of resources\n            ray.cancel(*rest_futures)\n            break\n        for id in ready_futures:\n            print(f\'completed value {id}, result {ray.get(id)}\')\n            futures = rest_futures\n\n## call order and see how long it takes to complete\nprint("WAIT took: ", timeit.timeit(lambda: as_available(), number=1))\n')),(0,a.kt)("p",null,"Since we are not running into timeouts with our code the output is the same as before. But with ",(0,a.kt)("inlineCode",{parentName:"p"},"num_returns")," set to ",(0,a.kt)("inlineCode",{parentName:"p"},"5")," the process will always collect 5 results before returning them - so we will get 2 chunks of our 10 orders."),(0,a.kt)("h2",{id:"composition"},"Composition"),(0,a.kt)("p",null,"The two most common methods of composition with remote functions in Ray are ",(0,a.kt)("strong",{parentName:"p"},"Pipelining and "),"Nested Parallelism__."),(0,a.kt)("h3",{id:"pipelines"},"Pipelines"),(0,a.kt)("p",null,"Pipelined function use an ",(0,a.kt)("inlineCode",{parentName:"p"},"ObjectRef")," objects from an earlier ",(0,a.kt)("inlineCode",{parentName:"p"},"ray.remote")," as parameters for a new remote function call. Ray coordinates those pipeline and will send the result from the first remote function directly to the remote host (or process in a local setup) that needs it."),(0,a.kt)("p",null,'In the following example we have two remote functions. The first one gets an integer value from "somewhere" and the second expects three integers to apply some mathematics on. We can call both functions with a single ',(0,a.kt)("inlineCode",{parentName:"p"},"ray.get")," and pipe the result from the first function into the second - and Ray handles the rest for us:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"import random\nimport ray\nimport time\n\n# first remote function\n## retrieve a value from somewhere\n@ray.remote\ndef generate_number(s: int, limit: int, sl: float) -> int :\n    # create a random seed from value of 's'\n    random.seed(s)\n    # wait for value of 'sl'\n    time.sleep(sl)\n    # create a random number between '0' and the value of 'limit'\n    return random.randint(0, limit)\n\n# second remote function\n## take values and do some math\n@ray.remote\ndef sum_values(v1: int, v2: int, v3: int) -> int :\n    # take three integer and add them up\n    return v1+v2+v3\n\n# use first remote function return  as input for second remote function\nprint(ray.get(sum_values.remote(generate_number.remote(1, 10, .1), generate_number.remote(5, 20, .2), generate_number.remote(7, 15, .3))))\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"python 02_ray-pipeline.py\n2023-01-25 13:49:46,733 INFO worker.py:1529 -- Started a local Ray instance.\nView the dashboard at 127.0.0.1:8265 \n31\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"Limitation"),": You can only use ",(0,a.kt)("inlineCode",{parentName:"p"},"ObjectRef")," directly. They cannot be added to a Python construct like a list. Trying to push the results from remote function one as a list does not work - you will get a ",(0,a.kt)("strong",{parentName:"p"},"TypeError")," because Ray will not execute the functions inside the list but forwards the values as type string:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"print(ray.get(sum_values.remote([generate_number.remote(1, 10, .1), generate_number.remote(5, 20, .2), generate_number.remote(7, 15, .3)])))\n")),(0,a.kt)("h3",{id:"nested-parallelism"},"Nested Parallelism"),(0,a.kt)("p",null,"Ray allows you to start additional remote functions from a remote function itself. There are two approaches to leverage the feature.  In the first case ",(0,a.kt)("inlineCode",{parentName:"p"},"remote_objrefs()")," we return all the ",(0,a.kt)("inlineCode",{parentName:"p"},"ObjectRef")," objects to the invoker of the aggregating function. So we need additional code that loops ove the returned futures and waits for the results."),(0,a.kt)("p",null,"In the second case ",(0,a.kt)("inlineCode",{parentName:"p"},"remote_values()")," the aggregating function waits for all the remote function to execute and returns the actual execution results:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-py"},"import random\nimport ray\nimport time\n\n# retrieve a value from somewhere\n@ray.remote\ndef generate_number(s: int, limit: int) -> int :\n    # create a random seed from value of 's'\n    random.seed(s)\n    # simulate processing time\n    time.sleep(.1)\n    # create a random number between '0' and the value of 'limit'\n    return random.randint(0, limit)\n\n# invoke multiple remote functions and return the 'ObjectRef's\n@ray.remote\ndef remote_objrefs():\n    results = []\n    for n in range(4):\n        results.append(generate_number.remote(n, 4*n))\n    return results\n\n# store returned 'ObjectRef's from remote_objrefs()\nfutures = ray.get(remote_objrefs.remote())\n\n# invoke multiple remote functions and return the resulting values directly\n@ray.remote\ndef remote_values():\n    results = []\n    for n in range(4):\n        results.append(generate_number.remote(n, 4*n))\n    return ray.get(results)\n\n# print returned results\nprint(ray.get(remote_values.remote()))\n\n\n# take returned 'ObjectRef's and get results\nwhile len(futures) > 0:\n    ready_futures, rest_futures = ray.wait(futures, timeout=600, num_returns=1)\n    # break when the return is smaller than num_returns\n    if len(ready_futures) < 1:\n        ray.cancel(*rest_futures)\n        break\n    for id in ready_futures:\n        print(f'completed result {ray.get(id)}')\n        futures = rest_futures\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"python 03_ray_nested_parallelism.py\n2023-01-25 15:14:11,235 INFO worker.py:1529 -- Started a local Ray instance.\nView the dashboard at 127.0.0.1:8265\n[0, 1, 0, 3]\ncompleted result 0\ncompleted result 3\ncompleted result 1\ncompleted result 0\n")))}m.isMDXComponent=!0},97572:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/photo-kt443t6d_64hdh43hfh6dgjdfhg4_d-296769d73822f07b0ac5dc952f56bfa1.jpg"}}]);